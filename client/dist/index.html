<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="resumeforge-api-base" content="https://a1b2c3d4e5.execute-api.ap-south-1.amazonaws.com/prod" />
    <script>
      ;(function setResumeForgeApiBase() {
        try {
          const meta = document.querySelector('meta[name="resumeforge-api-base"]');
          if (!meta || typeof meta.getAttribute !== 'function') {
            return;
          }

          const raw = meta.getAttribute('content') || '';
          const normalized = typeof raw === 'string' ? raw.trim() : '';
          if (!normalized || normalized === 'undefined' || normalized === 'null') {
            return;
          }

          if (typeof window !== 'undefined') {
            window.__RESUMEFORGE_API_BASE_URL__ = normalized;
          }
        } catch (error) {
          // Ignore runtime errors caused by constrained environments.
        }
      })();
    </script>
    <title>ResumeForge</title>
    
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #f8fafc;
      }
      #cloudfront-degraded-banner {
        box-sizing: border-box;
        width: min(720px, calc(100% - 2.5rem));
        margin: 2rem auto 0;
        padding: 1.5rem;
        border-radius: 16px;
        border: 1px solid rgba(234, 179, 8, 0.4);
        background: linear-gradient(180deg, rgba(253, 224, 71, 0.3) 0%, rgba(254, 249, 195, 0.45) 100%);
        color: #78350f;
        box-shadow: 0 20px 50px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }
      #cloudfront-degraded-banner[hidden] {
        display: none !important;
      }
      #cloudfront-degraded-banner .cloudfront-degraded__title {
        margin: 0;
        font-size: clamp(1.25rem, 3vw, 1.65rem);
        font-weight: 700;
        color: #92400e;
      }
      #cloudfront-degraded-banner .cloudfront-degraded__body {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.55;
      }
      #cloudfront-degraded-banner a {
        color: #b45309;
        font-weight: 600;
        text-decoration: none;
        word-break: break-all;
      }
      #cloudfront-degraded-banner a:hover,
      #cloudfront-degraded-banner a:focus {
        text-decoration: underline;
      }
      #cloudfront-degraded-banner code {
        font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        background: rgba(254, 240, 138, 0.6);
        padding: 0.2rem 0.45rem;
        border-radius: 6px;
        font-size: 0.9rem;
      }
      #static-asset-warning {
        box-sizing: border-box;
        width: min(720px, calc(100% - 2.5rem));
        margin: 3.5rem auto;
        padding: 1.75rem;
        border-radius: 16px;
        border: 1px solid rgba(220, 38, 38, 0.25);
        background: linear-gradient(180deg, #fff5f5 0%, #fffef9 100%);
        color: #7f1d1d;
        box-shadow: 0 24px 60px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }
      #static-asset-warning[hidden] {
        display: none !important;
      }
      #static-asset-warning .static-asset-warning__title {
        margin: 0;
        font-size: clamp(1.35rem, 3vw, 1.75rem);
        font-weight: 700;
      }
      #static-asset-warning .static-asset-warning__body {
        margin: 0;
        font-size: 1rem;
        line-height: 1.6;
      }
      #static-asset-warning code {
        font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        background: rgba(255, 255, 255, 0.65);
        padding: 0.2rem 0.45rem;
        border-radius: 6px;
        font-size: 0.95rem;
      }
      @media (prefers-color-scheme: dark) {
        body {
          background: #0f172a;
        }
        #cloudfront-degraded-banner {
          border-color: rgba(234, 179, 8, 0.55);
          background: linear-gradient(180deg, rgba(180, 83, 9, 0.4) 0%, rgba(120, 53, 15, 0.3) 100%);
          color: #fef3c7;
          box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
        }
        #cloudfront-degraded-banner code {
          background: rgba(120, 53, 15, 0.5);
          color: #fef3c7;
        }
        #cloudfront-degraded-banner a {
          color: #fbbf24;
        }
        #static-asset-warning {
          border-color: rgba(248, 113, 113, 0.4);
          background: linear-gradient(180deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.1) 100%);
          color: #fee2e2;
          box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
        }
        #static-asset-warning code {
          background: rgba(15, 23, 42, 0.4);
          color: #fef2f2;
        }
      }
    </style>
    <script type="module" crossorigin src="./assets/index-2547747c.js"></script>
    <link rel="stylesheet" href="./assets/index-88182d50.css">
  <script id="resumeforge-cloudfront-metadata">window.__RESUMEFORGE_CLOUDFRONT_METADATA__ = {"success":true,"cloudfront":{"stackName":"ResumeForge","url":"https://d109hwmzrqr39w.cloudfront.net","distributionId":"E3NEWPORTAL789","apiGatewayUrl":"https://a1b2c3d4e5.execute-api.ap-south-1.amazonaws.com/prod","originBucket":"resume-forge-app-2025","originRegion":"ap-south-1","originPath":"/static/client/prod/latest","updatedAt":"2024-11-05T09:30:00.000Z","degraded":false}};</script>
</head>
  <body>
    <div id="root"></div>
    <section
      id="cloudfront-degraded-banner"
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      hidden
      data-visible="false"
    >
      <h1 class="cloudfront-degraded__title">CloudFront is unavailable â€” using API Gateway fallback</h1>
      <p class="cloudfront-degraded__body">
        ResumeForge routed you directly to the API Gateway so you can continue working while the CDN recovers.
      </p>
      <p class="cloudfront-degraded__body" data-cloudfront-domain-wrapper hidden>
        Primary CloudFront domain: <code data-cloudfront-domain></code>
      </p>
      <p class="cloudfront-degraded__body" data-backup-api-wrapper hidden>
        Backup endpoint:
        <a data-backup-api-link href="#" rel="noopener noreferrer" target="_blank">
          <span data-backup-api-text></span>
        </a>
      </p>
      <p class="cloudfront-degraded__body" data-cloudfront-updated-wrapper hidden>
        Metadata last updated at <time data-cloudfront-updated></time>
      </p>
      <input type="hidden" name="resumeforge-backup-api-base" data-backup-api-base value="https://a1b2c3d4e5.execute-api.ap-south-1.amazonaws.com/prod" />
    </section>
    <div
      id="static-asset-warning"
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      hidden
      data-visible="false"
    >
      <h1 class="static-asset-warning__title">We're having trouble loading ResumeForge</h1>
      <p class="static-asset-warning__body">
        The static assets required to run the portal could not be downloaded. This often happens when the
        CDN is temporarily unavailable or a cached bundle was removed before the page refreshed.
      </p>
      <p class="static-asset-warning__body">
        Please refresh the page in a few minutes. If the issue persists, contact support so we can restore
        access.
      </p>
      <p class="static-asset-warning__body" data-static-asset-source-wrapper hidden>
        Missing file: <code data-static-asset-source></code>
      </p>
    </div>
    <script>
      ;(function () {
        const setBackupInputValue = (value) => {
          const inputs = document.querySelectorAll('input[data-backup-api-base]')
          const nextValue = typeof value === 'string' ? value : ''
          inputs.forEach((input) => {
            if (input && typeof input.setAttribute === 'function') {
              input.value = nextValue
              input.setAttribute('value', nextValue)
            }
          })
        }

        const inlinePublishedCloudfrontMetadata = (() => {
          try {
            if (typeof __PUBLISHED_CLOUDFRONT_METADATA__ === 'undefined') {
              return null
            }
            return __PUBLISHED_CLOUDFRONT_METADATA__ && typeof __PUBLISHED_CLOUDFRONT_METADATA__ === 'object'
              ? __PUBLISHED_CLOUDFRONT_METADATA__
              : null
          } catch (error) {
            return null
          }
        })()

        if (inlinePublishedCloudfrontMetadata && typeof window !== 'undefined') {
          try {
            const existing = window.__RESUMEFORGE_CLOUDFRONT_METADATA__
            if (!existing || typeof existing !== 'object') {
              window.__RESUMEFORGE_CLOUDFRONT_METADATA__ = inlinePublishedCloudfrontMetadata
            }
          } catch (error) {
            // Ignore inline metadata assignment failures in restricted environments.
          }
        }

        const degradeBanner = document.getElementById('cloudfront-degraded-banner')
        const degradeDomainWrapper = degradeBanner?.querySelector('[data-cloudfront-domain-wrapper]')
        const degradeDomainLabel = degradeBanner?.querySelector('[data-cloudfront-domain]')
        const degradeBackupWrapper = degradeBanner?.querySelector('[data-backup-api-wrapper]')
        const degradeBackupLink = degradeBanner?.querySelector('[data-backup-api-link]')
        const degradeBackupText = degradeBanner?.querySelector('[data-backup-api-text]')
        const degradeUpdatedWrapper = degradeBanner?.querySelector('[data-cloudfront-updated-wrapper]')
        const degradeUpdated = degradeBanner?.querySelector('[data-cloudfront-updated]')

        const revealDegradeBanner = ({ canonicalHost, backupUrl, updatedAt }) => {
          if (!degradeBanner) {
            return
          }

          if (canonicalHost && degradeDomainWrapper && degradeDomainLabel) {
            degradeDomainLabel.textContent = canonicalHost
            degradeDomainWrapper.hidden = false
          }

          if (backupUrl && degradeBackupWrapper && degradeBackupLink && degradeBackupText) {
            degradeBackupLink.href = backupUrl
            degradeBackupText.textContent = backupUrl
            degradeBackupWrapper.hidden = false
          }

          if (updatedAt && degradeUpdated && degradeUpdatedWrapper) {
            degradeUpdated.textContent = updatedAt
            degradeUpdatedWrapper.hidden = false
          }

          const wasVisible = degradeBanner.dataset.visible === 'true'
          if (!wasVisible) {
            degradeBanner.dataset.visible = 'true'
            degradeBanner.hidden = false
          }
        }

        const applyDegradedState = ({ canonicalUrl, backupUrl, updatedAt }) => {
          let canonicalHost = ''
          if (canonicalUrl) {
            try {
              canonicalHost = new URL(canonicalUrl, window.location.href).hostname
            } catch (error) {
              console.warn('Unable to parse CloudFront metadata URL.', error)
            }
          }

          const sanitizedBackup = backupUrl || ''

          if (sanitizedBackup) {
            setBackupInputValue(sanitizedBackup)
          }

          if (degradeBanner) {
            revealDegradeBanner({ canonicalHost, backupUrl: sanitizedBackup, updatedAt })
          }

          try {
            window.__RESUMEFORGE_CLOUDFRONT_DEGRADE__ = {
              canonicalUrl: canonicalUrl || '',
              backupApiGatewayUrl: sanitizedBackup,
              detectedAt: updatedAt || new Date().toISOString()
            }
          } catch (error) {
            console.warn('Unable to record CloudFront fallback metadata on the window.', error)
          }
        }

        const PUBLISHED_CLOUDFRONT_ENDPOINT_PATHS = Object.freeze([
          '/api/published-cloudfront',
          '/api/published-cloudfront.json'
        ])

        const loadPublishedCloudfrontMetadata = async () => {
          if (typeof fetch !== 'function') {
            return null
          }

          let lastError = null
          for (const path of PUBLISHED_CLOUDFRONT_ENDPOINT_PATHS) {
            const endpoints = buildAliasEndpointCandidates(path)
            for (const endpoint of endpoints) {
              if (!endpoint) {
                continue
              }

              try {
                const response = await fetch(endpoint, {
                  method: 'GET',
                  cache: 'no-store',
                  credentials: 'omit'
                })
                if (!response || !response.ok) {
                  continue
                }

                try {
                  const payload = await response.json()
                  if (payload && typeof payload === 'object') {
                    return payload
                  }
                } catch (innerError) {
                  lastError = innerError
                  continue
                }
              } catch (error) {
                lastError = error
              }
            }
          }

          if (lastError) {
            console.warn('Unable to load published CloudFront metadata.', lastError)
          }

          return null
        }

        if (degradeBanner) {
          const host = typeof window.location?.hostname === 'string' ? window.location.hostname : ''
          const onApiGateway = /\.execute-api\.[^.]+\.amazonaws\.com$/i.test(host)

          if (onApiGateway) {
            const fallbackOrigin = typeof window.location?.origin === 'string' ? window.location.origin : ''

            const handleMetadata = (payload) => {
              const canonicalUrl =
                typeof payload?.cloudfront?.url === 'string' && payload.cloudfront.url.trim()
                  ? payload.cloudfront.url.trim()
                  : ''
              const backupUrl =
                typeof payload?.cloudfront?.apiGatewayUrl === 'string' && payload.cloudfront.apiGatewayUrl.trim()
                  ? payload.cloudfront.apiGatewayUrl.trim()
                  : fallbackOrigin
              const updatedAt =
                typeof payload?.cloudfront?.updatedAt === 'string' && payload.cloudfront.updatedAt.trim()
                  ? payload.cloudfront.updatedAt.trim()
                  : ''

              applyDegradedState({ canonicalUrl, backupUrl, updatedAt })
            }

            loadPublishedCloudfrontMetadata().then((data) => handleMetadata(data)).catch((error) => {
              console.warn('Unable to load published CloudFront metadata.', error)
              handleMetadata(null)
            })
          } else {
            setBackupInputValue('')
          }
        }

        const HARD_REFRESH_PARAM = '__rf_refresh'
        const HARD_REFRESH_STORAGE_KEY = '__resumeforge_last_hard_refresh'
        const HARD_REFRESH_MIN_INTERVAL_MS = 5 * 60 * 1000

        try {
          const currentUrl = new URL(window.location.href)
          if (currentUrl.searchParams.has(HARD_REFRESH_PARAM)) {
            currentUrl.searchParams.delete(HARD_REFRESH_PARAM)
            if (typeof window.history?.replaceState === 'function') {
              window.history.replaceState(
                null,
                document.title,
                `${currentUrl.pathname}${currentUrl.search}${currentUrl.hash}`
              )
            }
          }
        } catch (error) {
          // Ignore URL parsing errors in constrained environments.
        }

        const warning = document.getElementById('static-asset-warning')
        if (!warning) {
          return
        }

        const sourceWrapper = warning.querySelector('[data-static-asset-source-wrapper]')
        const sourceLabel = warning.querySelector('[data-static-asset-source]')

        const detectHashedIndexCssPresence = () => {
          try {
            const links = document.querySelectorAll('link[rel~="stylesheet"]')
            for (const link of links) {
              if (!link) {
                continue
              }

              const rawHref =
                typeof link.getAttribute === 'function'
                  ? link.getAttribute('href') || link.href
                  : link.href

              if (!rawHref) {
                continue
              }

              let candidate = String(rawHref).trim()
              if (!candidate) {
                continue
              }

              try {
                const resolved = new URL(candidate, window.location.href)
                candidate = `${resolved.pathname}${resolved.search}`
              } catch (error) {
                // Ignore URL resolution failures and fall back to the raw href.
              }

              candidate = candidate.replace(/[#?].*$/, '')
              candidate = candidate.replace(/^(?:\.\.\/|\.\/)+/, '')
              candidate = candidate.replace(/^\/+/, '')
              candidate = candidate.replace(/\\/g, '/')

              if (/^assets\/index-(?!latest(?:\.|$))[\w.-]+\.css$/i.test(candidate)) {
                return true
              }
            }
          } catch (error) {
            // Ignore stylesheet detection errors in constrained environments.
          }

          return false
        }

        const hasInlineIndexCss = detectHashedIndexCssPresence()
        try {
          if (typeof window !== 'undefined') {
            window.__RESUMEFORGE_HAS_INDEX_CSS__ = hasInlineIndexCss
          }
        } catch (error) {
          // Ignore globals that cannot be set in restricted environments.
        }
        const aliasPaths = Object.freeze({
          js: '/assets/index-latest.js',
          css: hasInlineIndexCss ? '/assets/index-latest.css' : ''
        })

        const MANIFEST_ERROR_BACKOFF_MS = 5000
        const manifestState = {
          loaded: false,
          promise: null,
          lastErrorAt: 0,
          candidatesByExtension: { js: [], css: [] }
        }

        const HASHED_INDEX_ASSET_PATTERN = /^(?:\/)?assets\/index-(?!latest(?:\.|$))[\w.-]+\.(?:css|js)$/i

        const appendManifestCandidates = (extension, values) => {
          if (!extension || !Array.isArray(values) || values.length === 0) {
            return
          }

          const normalizedExtension = extension === 'css' ? 'css' : 'js'
          const bucket = Array.isArray(manifestState.candidatesByExtension[normalizedExtension])
            ? manifestState.candidatesByExtension[normalizedExtension]
            : []
          const seen = new Set(bucket)

          values.forEach((candidate) => {
            if (!candidate || seen.has(candidate)) {
              return
            }
            seen.add(candidate)
            bucket.push(candidate)
          })

          manifestState.candidatesByExtension[normalizedExtension] = bucket
        }

        const seedManifestCandidatesFromDom = () => {
          const discovered = []

          const captureCandidate = (rawValue) => {
            const normalized = normalizeManifestCandidate(rawValue)
            if (!normalized || !HASHED_INDEX_ASSET_PATTERN.test(normalized)) {
              return
            }
            discovered.push(normalized)
          }

          try {
            const scriptElements = document.querySelectorAll('script[src]')
            scriptElements.forEach((script) => {
              if (!script) {
                return
              }

              const value =
                typeof script.getAttribute === 'function'
                  ? script.getAttribute('src') || script.src
                  : script.src

              captureCandidate(value)
            })

            const stylesheetElements = document.querySelectorAll('link[rel]')
            stylesheetElements.forEach((link) => {
              if (!link) {
                return
              }

              const rel = typeof link.rel === 'string' ? link.rel.toLowerCase() : ''
              if (!rel.includes('stylesheet')) {
                return
              }

              const value =
                typeof link.getAttribute === 'function'
                  ? link.getAttribute('href') || link.href
                  : link.href

              captureCandidate(value)
            })
          } catch (error) {
            return
          }

          if (!discovered.length) {
            return
          }

          const buckets = categorizeManifestCandidates(discovered)
          appendManifestCandidates('js', buckets.js)
          appendManifestCandidates('css', buckets.css)
        }

        seedManifestCandidatesFromDom()

        const normalizeManifestCandidate = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          let candidate = value.trim()
          if (!candidate) {
            return ''
          }

          candidate = candidate.replace(/[#?].*$/, '')
          candidate = candidate.replace(/^(?:\.\/)+/g, '')
          candidate = candidate.replace(/^(?:\.\.\/)+/g, '')
          candidate = candidate.replace(/^\/+/, '')
          candidate = candidate.replace(/\\/g, '/')

          if (!candidate) {
            return ''
          }

          return candidate.startsWith('/') ? candidate : `/${candidate}`
        }

        const categorizeManifestCandidates = (values) => {
          const buckets = { js: [], css: [] }
          const seen = new Set()

          const append = (normalized) => {
            if (!normalized || seen.has(normalized)) {
              return
            }

            seen.add(normalized)

            if (/\.js$/i.test(normalized)) {
              buckets.js.push(normalized)
            } else if (/\.css$/i.test(normalized)) {
              buckets.css.push(normalized)
            }
          }

          if (Array.isArray(values)) {
            values.forEach((value) => {
              append(normalizeManifestCandidate(value))
            })
          }

          return buckets
        }

        const resolveManifestPayload = (payload) => {
          if (!payload || typeof payload !== 'object') {
            return null
          }

          if (payload.manifest && typeof payload.manifest === 'object') {
            return resolveManifestPayload(payload.manifest)
          }

          if (payload.data && typeof payload.data === 'object') {
            return resolveManifestPayload(payload.data)
          }

          return payload
        }

        const MANIFEST_API_PATH = '/api/static-manifest'

        const ensureManifestCandidatesLoaded = () => {
          if (manifestState.loaded) {
            return manifestState.promise || Promise.resolve(manifestState.candidatesByExtension)
          }

          if (manifestState.promise) {
            return manifestState.promise
          }

          const now = Date.now()
          if (manifestState.lastErrorAt && now - manifestState.lastErrorAt < MANIFEST_ERROR_BACKOFF_MS) {
            return null
          }

          if (typeof fetch !== 'function') {
            manifestState.loaded = true
            return Promise.resolve(manifestState.candidatesByExtension)
          }

          manifestState.promise = (async () => {
            try {
              const endpoints = buildAliasEndpointCandidates(MANIFEST_API_PATH)
              for (const endpoint of endpoints) {
                if (!endpoint) {
                  continue
                }

                let response
                try {
                  response = await fetch(endpoint, {
                    cache: 'no-store',
                    credentials: 'omit'
                  })
                } catch (error) {
                  continue
                }

                if (!response || !response.ok) {
                  continue
                }

                let payload
                try {
                  payload = await response.json()
                } catch (error) {
                  continue
                }

                const manifest = resolveManifestPayload(payload)
                const combined = Array.isArray(manifest?.hashedIndexAssets) && manifest.hashedIndexAssets.length
                  ? manifest.hashedIndexAssets
                  : Array.isArray(manifest?.assets)
                    ? manifest.assets
                    : []

                manifestState.candidatesByExtension = categorizeManifestCandidates(combined)
                manifestState.loaded = true
                manifestState.lastErrorAt = 0
                return manifestState.candidatesByExtension
              }

              manifestState.lastErrorAt = Date.now()
              return manifestState.candidatesByExtension
            } catch (error) {
              manifestState.lastErrorAt = Date.now()
              return manifestState.candidatesByExtension
            } finally {
              manifestState.promise = null
            }
          })()

          return manifestState.promise
        }

        const normalizeAliasBase = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          const trimmed = value.trim()
          if (!trimmed) {
            return ''
          }

          try {
            const resolved = new URL(trimmed, window.location.href)
            const pathname = resolved.pathname.replace(/\/*$/, '')
            return `${resolved.origin}${pathname}`
          } catch (error) {
            return ''
          }
        }

        const normalizeApiProxyBase = (value) => {
          const normalized = normalizeAliasBase(value)
          if (!normalized) {
            return ''
          }

          try {
            const resolved = new URL(normalized, window.location.href)
            const host = (resolved.hostname || '').toLowerCase()
            if (!host) {
              return ''
            }

            if (/\.s3[.-]/.test(host)) {
              return ''
            }

            if (/\.cloudfront\.net$/.test(host)) {
              const currentHost =
                typeof window?.location?.hostname === 'string'
                  ? window.location.hostname.toLowerCase()
                  : ''

              if (!currentHost || currentHost !== host) {
                return ''
              }
            }
          } catch (error) {
            return ''
          }

          return normalized
        }

        const normalizeAliasOriginPath = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          const trimmed = value.trim()
          if (!trimmed || trimmed === '/') {
            return ''
          }

          const prefixed = trimmed.startsWith('/') ? trimmed : `/${trimmed}`
          const withoutTrailing = prefixed.replace(/\/+$/, '')
          return withoutTrailing || ''
        }

        const joinAliasUrl = (base, aliasPath) => {
          if (!aliasPath) {
            return ''
          }

          if (!base) {
            return aliasPath
          }

          const normalizedBase = base.replace(/\/*$/, '')
          const normalizedPath = aliasPath.startsWith('/') ? aliasPath : `/${aliasPath}`
          return `${normalizedBase}${normalizedPath}`
        }

        const buildStaticProxyUrl = (base, aliasPath) => {
          if (!aliasPath) {
            return ''
          }

          const normalizedBase = typeof base === 'string' ? base.trim() : ''
          const sanitizedAsset = aliasPath.replace(/^\/+/, '')
          if (!normalizedBase || !sanitizedAsset) {
            return ''
          }

          const baseWithoutSlash = normalizedBase.replace(/\/+$/, '')
          return `${baseWithoutSlash}/api/static-proxy?asset=${encodeURIComponent(sanitizedAsset)}`
        }

        const extractAwsRegionFromUrl = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          const trimmed = value.trim()
          if (!trimmed) {
            return ''
          }

          try {
            const resolved = new URL(trimmed, window.location.href)
            const host = (resolved.hostname || '').toLowerCase()
            if (!host) {
              return ''
            }

            const executeMatch = host.match(/^[^.]+\.execute-api\.([a-z0-9-]+)\.amazonaws\.com$/)
            if (executeMatch && executeMatch[1]) {
              return executeMatch[1]
            }

            const s3WebsiteMatch = host.match(/\.s3[.-]website[.-]([a-z0-9-]+)\.amazonaws\.com$/)
            if (s3WebsiteMatch && s3WebsiteMatch[1]) {
              return s3WebsiteMatch[1]
            }

            const s3Match = host.match(/\.s3[.-]([a-z0-9-]+)\.amazonaws\.com$/)
            if (s3Match && s3Match[1]) {
              return s3Match[1]
            }

            const segments = host.split('.')
            for (const segment of segments) {
              if (/^[a-z]{2}-[a-z0-9-]+-[0-9]+$/.test(segment)) {
                return segment
              }
            }
          } catch (error) {
            return ''
          }

          return ''
        }

        const buildS3BaseCandidates = (bucket, regions = []) => {
          if (typeof bucket !== 'string') {
            return []
          }

          const trimmedBucket = bucket.trim()
          if (!trimmedBucket) {
            return []
          }

          const normalizedBucket = trimmedBucket
          const bases = []
          const seen = new Set()

          const addBase = (candidate) => {
            if (!candidate || seen.has(candidate)) {
              return
            }
            seen.add(candidate)
            bases.push(candidate)
          }

          addBase(`https://${normalizedBucket}.s3.amazonaws.com`)

          if (Array.isArray(regions)) {
            regions.forEach((regionValue) => {
              if (!regionValue) {
                return
              }

              const region = String(regionValue).trim().toLowerCase()
              if (!region) {
                return
              }

              addBase(`https://${normalizedBucket}.s3.${region}.amazonaws.com`)
              addBase(`https://${normalizedBucket}.s3-${region}.amazonaws.com`)
              addBase(`https://${normalizedBucket}.s3-website.${region}.amazonaws.com`)
              addBase(`https://${normalizedBucket}.s3-website-${region}.amazonaws.com`)
              addBase(`https://s3.${region}.amazonaws.com/${normalizedBucket}`)
              addBase(`https://s3-${region}.amazonaws.com/${normalizedBucket}`)
            })
          }

          return bases
        }

        const resolveAliasBaseCandidates = () => {
          const candidates = []
          const seen = new Set()

          const addCandidate = (raw) => {
            const normalized = normalizeAliasBase(raw)
            if (!normalized || seen.has(normalized)) {
              return
            }
            seen.add(normalized)
            candidates.push(normalized)
          }

          try {
            const explicitGlobal =
              typeof window.__RESUMEFORGE_API_BASE_URL__ === 'string'
                ? window.__RESUMEFORGE_API_BASE_URL__.trim()
                : ''
            if (explicitGlobal) {
              addCandidate(explicitGlobal)
            }
          } catch (error) {
            // Ignore global override parsing issues.
          }

          try {
            const meta = document.querySelector('meta[name="resumeforge-api-base"]')
            if (meta && typeof meta.getAttribute === 'function') {
              addCandidate(meta.getAttribute('content'))
            }
          } catch (error) {
            // Ignore metadata parsing errors.
          }

          try {
            const inputs = document.querySelectorAll('input[data-backup-api-base]')
            inputs.forEach((input) => {
              if (input) {
                const value =
                  typeof input.value === 'string'
                    ? input.value
                    : typeof input.getAttribute === 'function'
                      ? input.getAttribute('value')
                      : ''
                addCandidate(value)
              }
            })
          } catch (error) {
            // Ignore backup input parsing errors.
          }

          addCandidate(window.location.origin || '')

          // Always include an empty base so we eventually retry the alias path as-is.
          candidates.push('')

          return candidates
        }

        const aliasBaseCandidates = resolveAliasBaseCandidates()
        const aliasBaseSeen = new Set(aliasBaseCandidates)
        const apiProxyCandidates = []
        const apiProxySeen = new Set()

        const addApiProxyCandidate = (value) => {
          const normalized = normalizeApiProxyBase(value)
          if (!normalized || apiProxySeen.has(normalized)) {
            return false
          }
          apiProxySeen.add(normalized)
          apiProxyCandidates.push(normalized)
          return true
        }

        aliasBaseCandidates.forEach((candidate) => {
          addApiProxyCandidate(candidate)
        })

        try {
          ensureManifestCandidatesLoaded()
        } catch (error) {
          // Ignore manifest prefetch failures in constrained environments.
        }

        const addAliasBaseCandidate = (value) => {
          const normalized = normalizeAliasBase(value)
          if (!normalized || aliasBaseSeen.has(normalized)) {
            return false
          }
          aliasBaseSeen.add(normalized)
          aliasBaseCandidates.push(normalized)
          addApiProxyCandidate(normalized)
          return true
        }

        const applyAliasMetadataCandidates = (rawMetadata) => {
          if (!rawMetadata || typeof rawMetadata !== 'object') {
            return false
          }

          const metadata =
            rawMetadata && typeof rawMetadata.cloudfront === 'object'
              ? rawMetadata.cloudfront
              : rawMetadata

          if (!metadata || typeof metadata !== 'object') {
            return false
          }

          const originPath = normalizeAliasOriginPath(metadata.originPath)
          const regionHints = new Set()

          const addRegionHint = (value) => {
            if (!value) {
              return
            }
            const normalized = String(value).trim().toLowerCase()
            if (normalized) {
              regionHints.add(normalized)
            }
          }

          addRegionHint(extractAwsRegionFromUrl(metadata.apiGatewayUrl))
          addRegionHint(extractAwsRegionFromUrl(metadata.url))
          addRegionHint(metadata.originRegion)

          const bucketBases = buildS3BaseCandidates(
            typeof metadata.originBucket === 'string' ? metadata.originBucket : '',
            Array.from(regionHints),
          )

          let added = false

          const applyCandidate = (candidate) => {
            if (candidate) {
              addApiProxyCandidate(candidate)
            }
            if (addAliasBaseCandidate(candidate)) {
              added = true
            }

            if (candidate && originPath && addAliasBaseCandidate(joinAliasUrl(candidate, originPath))) {
              added = true
            }
          }

          const directCandidates = []
          if (typeof metadata.apiGatewayUrl === 'string') {
            directCandidates.push(metadata.apiGatewayUrl)
          }
          if (typeof metadata.url === 'string') {
            directCandidates.push(metadata.url)
          }

          directCandidates.forEach(applyCandidate)
          bucketBases.forEach(applyCandidate)

          if (originPath && addAliasBaseCandidate(joinAliasUrl('', originPath))) {
            added = true
          }

          return added
        }

        let aliasMetadataLoaded = false
        let aliasMetadataPromise = null

        try {
          if (
            typeof window !== 'undefined' &&
            window.__RESUMEFORGE_CLOUDFRONT_METADATA__ &&
            applyAliasMetadataCandidates(window.__RESUMEFORGE_CLOUDFRONT_METADATA__)
          ) {
            aliasMetadataLoaded = true
          }
        } catch (error) {
          // Ignore inline metadata parsing failures and fall back to runtime loading.
        }

        function buildAliasEndpointCandidates(path) {
          const endpoints = []
          const seen = new Set()

          const append = (value) => {
            if (typeof value !== 'string') {
              return
            }

            const normalized = value.trim()
            if (!normalized || seen.has(normalized)) {
              return
            }

            seen.add(normalized)
            endpoints.push(normalized)
          }

          append(path)

          aliasBaseCandidates.forEach((base) => {
            if (!base) {
              return
            }

            append(joinAliasUrl(base, path))
          })

          return endpoints
        }

        const buildMetadataEndpointCandidates = () => {
          const endpoints = []
          const seen = new Set()

          const append = (candidate) => {
            if (!candidate || seen.has(candidate)) {
              return
            }
            seen.add(candidate)
            endpoints.push(candidate)
          }

          PUBLISHED_CLOUDFRONT_ENDPOINT_PATHS.forEach((path) => {
            const list = buildAliasEndpointCandidates(path)
            list.forEach(append)
          })

          return endpoints
        }

        const ensureAliasMetadataLoaded = () => {
          if (aliasMetadataLoaded) {
            return aliasMetadataPromise || Promise.resolve(false)
          }

          if (aliasMetadataPromise) {
            return aliasMetadataPromise
          }

          aliasMetadataPromise = (async () => {
            try {
              if (typeof fetch !== 'function') {
                return false
              }

              const endpoints = buildMetadataEndpointCandidates()
              for (const endpoint of endpoints) {
                if (!endpoint) {
                  continue
                }

                let response
                try {
                  response = await fetch(endpoint, {
                    cache: 'no-store',
                    credentials: 'omit'
                  })
                } catch (error) {
                  continue
                }

                if (!response || !response.ok) {
                  continue
                }

                let payload
                try {
                  payload = await response.json()
                } catch (error) {
                  continue
                }

                try {
                  if (typeof window !== 'undefined') {
                    window.__RESUMEFORGE_CLOUDFRONT_METADATA__ = payload
                  }
                } catch (error) {
                  // Ignore global assignment errors.
                }

                if (applyAliasMetadataCandidates(payload)) {
                  return true
                }
              }

              return false
            } catch (error) {
              return false
            } finally {
              aliasMetadataLoaded = true
            }
          })().finally(() => {
            aliasMetadataPromise = null
          })

          return aliasMetadataPromise
        }

        const buildAliasUrlForAttempt = (aliasPath, attemptIndex) => {
          if (typeof attemptIndex !== 'number' || attemptIndex < 0) {
            return { url: aliasPath, base: '' }
          }

          const base = aliasBaseCandidates[attemptIndex] ?? ''
          const url = joinAliasUrl(base, aliasPath)
          return { url, base }
        }

        const appendCacheBustParam = (source) => {
          if (!source) {
            return ''
          }

          try {
            const parsed = new URL(source, window.location.href)
            parsed.searchParams.set('__rf_retry', Date.now().toString(36))
            return parsed.href
          } catch (error) {
            const separator = source.includes('?') ? '&' : '?'
            return `${source}${separator}__rf_retry=${Date.now().toString(36)}`
          }
        }

        const attemptCacheBustingReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          if (element.dataset?.resumeforgeAssetRetry === 'true') {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const originalSource = describeSource(element)
          if (!originalSource) {
            return false
          }

          const retrySource = appendCacheBustParam(originalSource)
          if (!retrySource) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const replacement = element.cloneNode(true)

          if (isStylesheet) {
            replacement.href = retrySource
          } else {
            replacement.src = retrySource
          }

          replacement.setAttribute('data-src', retrySource)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeOriginalSource = originalSource

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeOriginalSource = originalSource

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset with cache bust parameter.', {
              source: originalSource,
              retry: retrySource
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        const logFailure = (sourceText) => {
          if (sourceText) {
            console.error('ResumeForge static asset failed to load.', { source: sourceText })
          } else {
            console.error('ResumeForge static asset failed to load.')
          }
        }

        const recordHardRefreshAttempt = () => {
          try {
            const storage = window.sessionStorage || window.localStorage
            if (!storage) {
              return
            }

            storage.setItem(
              HARD_REFRESH_STORAGE_KEY,
              Date.now().toString()
            )
          } catch (error) {
            // Ignore storage errors (private mode, etc.)
          }
        }

        const shouldAttemptHardRefresh = () => {
          try {
            const storage = window.sessionStorage || window.localStorage
            if (!storage) {
              return true
            }

            const rawTimestamp = storage.getItem(HARD_REFRESH_STORAGE_KEY)
            if (!rawTimestamp) {
              return true
            }

            const parsed = Number.parseInt(rawTimestamp, 10)
            if (!Number.isFinite(parsed)) {
              return true
            }

            return Date.now() - parsed >= HARD_REFRESH_MIN_INTERVAL_MS
          } catch (error) {
            return true
          }
        }

        const attemptHardRefresh = () => {
          if (!shouldAttemptHardRefresh()) {
            return false
          }

          try {
            const current = new URL(window.location.href)
            if (!current.searchParams.has(HARD_REFRESH_PARAM)) {
              current.searchParams.set(
                HARD_REFRESH_PARAM,
                Date.now().toString(36)
              )
            } else {
              current.searchParams.set(
                HARD_REFRESH_PARAM,
                Date.now().toString(36)
              )
            }

            recordHardRefreshAttempt()
            window.location.replace(current.href)
            return true
          } catch (error) {
            try {
              recordHardRefreshAttempt()
              window.location.reload()
              return true
            } catch (innerError) {
              return false
            }
          }
        }

        const revealWarning = (sourceText) => {
          if (sourceText && sourceLabel && sourceWrapper) {
            sourceLabel.textContent = sourceText
            sourceWrapper.hidden = false
          }

          const wasVisible = warning.dataset.visible === 'true'
          if (!wasVisible) {
            warning.dataset.visible = 'true'
            warning.hidden = false
          }
          return wasVisible
        }

        const describeSource = (element) => {
          if (!element) {
            return ''
          }

          const originalDatasetSource =
            typeof element.dataset?.resumeforgeOriginalSource === 'string'
              ? element.dataset.resumeforgeOriginalSource
              : ''

          const rawSource =
            originalDatasetSource ||
            (typeof element.getAttribute === 'function' && element.getAttribute('data-src')) ||
            element.src ||
            element.href ||
            ''

          if (!rawSource) {
            return ''
          }

          try {
            const resolved = new URL(rawSource, window.location.href)
            if (resolved.origin === window.location.origin) {
              return `${resolved.pathname}${resolved.search}`
            }
            return resolved.href
          } catch (error) {
            return rawSource
          }
        }

        const attemptStaticProxyReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          if (!apiProxyCandidates.length) {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const rawAttempt = element.dataset?.resumeforgeProxyAttempt || '0'
          let attemptIndex = Number.parseInt(rawAttempt, 10)
          if (!Number.isFinite(attemptIndex) || attemptIndex < 0) {
            attemptIndex = 0
          }

          const originalSource = describeSource(element)
          const normalizedSource = (() => {
            if (!originalSource) {
              return ''
            }

            let candidate = String(originalSource).trim()
            if (!candidate) {
              return ''
            }

            candidate = candidate.replace(/[#?].*$/, '')
            candidate = candidate.replace(/^(?:\.\.\/|\.\/)+/, '')
            candidate = candidate.replace(/^\/+/, '')
            candidate = candidate.replace(/\\/g, '/')
            if (!candidate) {
              return ''
            }

            return candidate.startsWith('/') ? candidate : `/${candidate}`
          })()

          const aliasPath = isScript ? aliasPaths.js : aliasPaths.css
          if (!aliasPath && !normalizedSource) {
            return false
          }

          const preferredAssetPath = (() => {
            if (normalizedSource && HASHED_INDEX_ASSET_PATTERN.test(normalizedSource)) {
              return normalizedSource
            }

            return aliasPath || ''
          })()

          if (!preferredAssetPath) {
            return false
          }

          const candidateAssets = []
          if (preferredAssetPath) {
            candidateAssets.push(preferredAssetPath)
          }
          if (aliasPath && aliasPath !== preferredAssetPath) {
            candidateAssets.push(aliasPath)
          }

          if (!candidateAssets.length || apiProxyCandidates.length === 0) {
            return false
          }

          let selectedUrl = ''
          let selectedAsset = ''
          let selectedBase = ''
          const totalCombinations = candidateAssets.length * apiProxyCandidates.length
          let nextPointer = attemptIndex

          if (!Number.isFinite(nextPointer) || nextPointer < 0) {
            nextPointer = 0
          }

          let cursor = nextPointer

          while (cursor < totalCombinations) {
            const assetIndex = Math.floor(cursor / apiProxyCandidates.length)
            const baseIndex = cursor % apiProxyCandidates.length
            const assetCandidate = candidateAssets[assetIndex]
            const baseCandidate = apiProxyCandidates[baseIndex]
            const proxyUrl = buildStaticProxyUrl(baseCandidate, assetCandidate)
            cursor += 1

            if (proxyUrl) {
              selectedUrl = proxyUrl
              selectedAsset = assetCandidate
              selectedBase = baseCandidate
              break
            }
          }

          element.dataset.resumeforgeProxyAttempt = String(cursor)

          if (!selectedUrl) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const replacement = element.cloneNode(true)

          if (isStylesheet) {
            replacement.href = selectedUrl
          } else {
            replacement.src = selectedUrl
          }

          replacement.setAttribute('data-src', selectedUrl)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeAssetProxy = 'true'
          replacement.dataset.resumeforgeProxyAttempt = String(cursor)
          if (selectedAsset) {
            replacement.dataset.resumeforgeProxyAsset = selectedAsset
          }
          if (selectedBase) {
            replacement.dataset.resumeforgeProxyBase = selectedBase
          }
          if (originalSource) {
            replacement.dataset.resumeforgeOriginalSource = originalSource
          }

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeAssetProxy = 'true'
          element.dataset.resumeforgeProxyAttempt = String(cursor)
          if (selectedAsset && !element.dataset.resumeforgeProxyAsset) {
            element.dataset.resumeforgeProxyAsset = selectedAsset
          }
          if (selectedBase && !element.dataset.resumeforgeProxyBase) {
            element.dataset.resumeforgeProxyBase = selectedBase
          }
          if (originalSource && !element.dataset.resumeforgeOriginalSource) {
            element.dataset.resumeforgeOriginalSource = originalSource
          }

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset via API proxy fallback.', {
              source: originalSource || '',
              proxy: selectedUrl,
              asset: selectedAsset || '',
              base: selectedBase || ''
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        const attemptProxyOrAliasReload = (element) => {
          if (attemptStaticProxyReload(element)) {
            return true
          }

          return attemptAliasReload(element)
        }

        function attemptAliasReload(element) {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          const attemptIndex = Number.parseInt(element.dataset?.resumeforgeAliasAttempt || '0', 10)
          if (!Number.isFinite(attemptIndex) || attemptIndex < 0) {
            return false
          }

          if (attemptIndex >= aliasBaseCandidates.length) {
            if (attemptStaticProxyReload(element)) {
              return true
            }
            ensureAliasMetadataLoaded()
              .then((added) => {
                if (!added) {
                  return
                }
                if (!element) {
                  return
                }
                if (typeof element.isConnected === 'boolean') {
                  if (!element.isConnected) {
                    return
                  }
                } else {
                  const root = document?.documentElement
                  if (!root || typeof root.contains !== 'function' || !root.contains(element)) {
                    return
                  }
                }
                attemptAliasReload(element)
              })
              .catch(() => {
                // Ignore metadata lookup failures and allow other fallbacks to proceed.
              })
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const aliasPath = isScript ? aliasPaths.js : aliasPaths.css
          if (!aliasPath) {
            return false
          }

          const { url: aliasUrl, base: aliasBase } = buildAliasUrlForAttempt(aliasPath, attemptIndex)
          if (!aliasUrl) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const originalSource = describeSource(element)
          const replacement = element.cloneNode(true)

          const cacheBustedAliasUrl = appendCacheBustParam(aliasUrl)
          const effectiveAliasUrl = cacheBustedAliasUrl || aliasUrl

          if (isStylesheet) {
            replacement.href = effectiveAliasUrl
          } else {
            replacement.src = effectiveAliasUrl
          }

          replacement.setAttribute('data-src', effectiveAliasUrl)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeAssetAlias = 'true'
          replacement.dataset.resumeforgeAliasAttempt = String(attemptIndex + 1)
          if (aliasBase) {
            replacement.dataset.resumeforgeAliasBase = aliasBase
          }
          if (originalSource) {
            replacement.dataset.resumeforgeOriginalSource = originalSource
          }

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeAssetAlias = 'true'
          element.dataset.resumeforgeAliasAttempt = String(attemptIndex + 1)
          if (aliasBase) {
            element.dataset.resumeforgeAliasBase = aliasBase
          }
          if (originalSource && !element.dataset.resumeforgeOriginalSource) {
            element.dataset.resumeforgeOriginalSource = originalSource
          }

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset via alias fallback.', {
              source: originalSource || '',
              alias: aliasUrl,
              resolved: effectiveAliasUrl,
              base: aliasBase
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        const attemptManifestReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const extension = isStylesheet ? 'css' : 'js'
          const originalSource = describeSource(element)

          const applyCandidates = (candidates) => {
            const list = Array.isArray(candidates?.[extension]) ? candidates[extension] : []
            if (!list.length) {
              return false
            }

            const rawAttempt = element.dataset?.resumeforgeManifestAttempt || '0'
            const parsedAttempt = Number.parseInt(rawAttempt, 10)
            const startIndex = Number.isFinite(parsedAttempt) && parsedAttempt >= 0 ? parsedAttempt : 0

            for (let index = startIndex; index < list.length; index += 1) {
              const candidate = list[index]
              if (!candidate) {
                continue
              }

              let normalizedCandidate = candidate
              try {
                const resolved = new URL(candidate, window.location.href)
                normalizedCandidate =
                  resolved.origin === window.location.origin
                    ? `${resolved.pathname}${resolved.search}`
                    : resolved.href
              } catch (error) {
                normalizedCandidate = candidate
              }

              if (normalizedCandidate && originalSource && normalizedCandidate === originalSource) {
                element.dataset.resumeforgeManifestAttempt = String(index + 1)
                continue
              }

              const parent = element.parentNode
              if (!parent || typeof parent.replaceChild !== 'function') {
                return false
              }

              const replacement = element.cloneNode(true)

              if (isStylesheet) {
                replacement.href = candidate
              } else {
                replacement.src = candidate
              }

              replacement.setAttribute('data-src', candidate)
              replacement.dataset.resumeforgeAssetRetry = 'true'
              replacement.dataset.resumeforgeAssetManifest = 'true'
              replacement.dataset.resumeforgeManifestAttempt = String(index + 1)
              if (originalSource) {
                replacement.dataset.resumeforgeOriginalSource = originalSource
              }

              element.dataset.resumeforgeAssetRetry = 'true'
              element.dataset.resumeforgeAssetManifest = 'true'
              element.dataset.resumeforgeManifestAttempt = String(index + 1)
              if (originalSource && !element.dataset.resumeforgeOriginalSource) {
                element.dataset.resumeforgeOriginalSource = originalSource
              }

              try {
                parent.replaceChild(replacement, element)
              } catch (error) {
                try {
                  parent.removeChild(element)
                  parent.appendChild(replacement)
                } catch (innerError) {
                  return false
                }
              }

              try {
                console.warn('Retrying ResumeForge static asset via manifest fallback.', {
                  source: originalSource || '',
                  manifest: candidate
                })
              } catch (error) {
                // Ignore logging errors in constrained environments.
              }

              return true
            }

            return false
          }

          if (applyCandidates(manifestState.candidatesByExtension)) {
            return true
          }

          const promise = ensureManifestCandidatesLoaded()
          if (!promise) {
            return false
          }

          promise
            .then((candidates) => {
              if (!candidates) {
                attemptProxyOrAliasReload(element)
                return
              }

              const connected = (() => {
                if (!element) {
                  return false
                }
                if (typeof element.isConnected === 'boolean') {
                  return element.isConnected
                }
                const root = document?.documentElement
                if (!root || typeof root.contains !== 'function') {
                  return true
                }
                return root.contains(element)
              })()

              if (!connected) {
                return
              }

              if (!applyCandidates(candidates)) {
                attemptProxyOrAliasReload(element)
              }
            })
            .catch(() => {
              attemptProxyOrAliasReload(element)
            })

          return true
        }

        window.addEventListener(
          'error',
          (event) => {
            if (!event || !event.target) {
              return
            }

            const target = event.target
            const tagName = typeof target.tagName === 'string' ? target.tagName.toLowerCase() : ''
            const isStylesheet = tagName === 'link' && typeof target.rel === 'string' && target.rel.toLowerCase() === 'stylesheet'
            const isScript = tagName === 'script'

            if (!isScript && !isStylesheet) {
              return
            }

            if (attemptManifestReload(target)) {
              return
            }

            if (attemptStaticProxyReload(target)) {
              return
            }

            if (attemptAliasReload(target)) {
              return
            }

            if (attemptCacheBustingReload(target)) {
              return
            }

            const sourceText = describeSource(target)

            if (attemptHardRefresh()) {
              return
            }

            revealWarning(sourceText)
            logFailure(sourceText)
          },
          true
        )

        window.addEventListener('unhandledrejection', (event) => {
          if (!event || !event.reason) {
            return
          }

          const reason = event.reason
          const message =
            typeof reason === 'string'
              ? reason
              : typeof reason.message === 'string'
                ? reason.message
                : typeof reason.error === 'string'
                  ? reason.error
                  : ''

          if (!message) {
            return
          }

          if (/loading chunk|importing module|Failed to fetch dynamically imported module|module script/i.test(message)) {
            revealWarning('')
            logFailure('')
          }
        })
      })()
    </script>
    
  </body>
</html>
