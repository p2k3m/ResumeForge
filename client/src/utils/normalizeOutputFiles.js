const URL_KEYS = ['url', 'fileUrl', 'typeUrl', 'downloadUrl', 'href', 'link', 'signedUrl']
const EXPIRES_AT_KEYS = [
  'expiresAt',
  'expiryAt',
  'expiry',
  'expires_at',
  'expiry_at',
  'expiresISO',
  'expiryISO',
  'expiresAtIso',
  'expiresAtISO',
  'expiryIso',
  'expiryISO'
]
const EXPIRES_IN_KEYS = [
  'expiresInSeconds',
  'expiresIn',
  'expiryInSeconds',
  'expirySeconds',
  'expires_in_seconds',
  'expires_in',
  'expiry_in_seconds',
  'expiry_in'
]
const EXPIRES_EPOCH_KEYS = [
  'expiresAtEpoch',
  'expiryAtEpoch',
  'expiryEpoch',
  'expiresEpoch',
  'expiresAtTimestamp',
  'expiryTimestamp',
  'expiryEpochSeconds',
  'expiresEpochSeconds',
  'expires_at_epoch',
  'expiry_at_epoch'
]
const EXPIRES_MS_KEYS = [
  'expiresAtMs',
  'expiryAtMs',
  'expiryMs',
  'expiresMs',
  'expires_at_ms',
  'expiry_at_ms'
]

const KNOWN_AUTO_TYPES = new Set([
  'original_upload',
  'original',
  'version1',
  'version2',
  'cover_letter1',
  'cover_letter2'
])

const PRESERVED_STRING_FIELDS = [
  'fileName',
  'title',
  'template',
  'templateId',
  'templateName',
  'coverTemplate',
  'coverTemplateId',
  'coverTemplateName'
]

const TEMPLATE_META_STRING_FIELDS = [
  'id',
  'name',
  'variant',
  'category',
  'template',
  'type',
  'description',
  'label'
]

const PRESENTATION_STRING_FIELDS = [
  'label',
  'description',
  'badgeText',
  'badgeStyle',
  'buttonStyle',
  'secondaryButtonStyle',
  'cardAccent',
  'cardBorder',
  'linkLabel',
  'category'
]

const BANNED_STATUS_PATTERNS = [
  /\btest(ing)?\b/i,
  /\bpreview\b/i,
  /\bstale\b/i,
  /\bsandbox\b/i,
  /\bdraft\b/i,
  /\bplaceholder\b/i,
  /\bsample\b/i,
  /\bdummy\b/i,
  /\barchive(d)?\b/i,
  /\bexpired?\b/i
]

const USER_STATUS_VALUES = new Set([
  'user',
  'manual',
  'upload',
  'original',
  'candidate',
  'selected',
  'user-selected',
  'user_selected'
])

const AUTO_STATUS_VALUES = new Set([
  'auto',
  'automatic',
  'auto-enhanced',
  'auto_enhanced',
  'auto-generated',
  'auto_generated',
  'autogenerated',
  'generated',
  'enhanced',
  'ai',
  'ai-generated',
  'ai_generated'
])

function toLowerSafe(value) {
  return typeof value === 'string' ? value.trim().toLowerCase() : ''
}

function normalizeTagList(value) {
  if (!value) return []
  if (Array.isArray(value)) {
    return value.map(toLowerSafe).filter(Boolean)
  }
  if (typeof value === 'string') {
    return [toLowerSafe(value)].filter(Boolean)
  }
  if (value && typeof value === 'object') {
    return Object.values(value)
      .map((entry) => (typeof entry === 'string' ? entry : ''))
      .map(toLowerSafe)
      .filter(Boolean)
  }
  return []
}

function matchesBannedStatus(value) {
  const normalized = toLowerSafe(value)
  if (!normalized) return false
  return BANNED_STATUS_PATTERNS.some((pattern) => pattern.test(normalized))
}

function hasTrustedMetadata(entry) {
  if (!entry || typeof entry !== 'object') {
    return false
  }

  const presentation = entry.presentation
  if (presentation && typeof presentation === 'object') {
    const presentationStrings = PRESENTATION_STRING_FIELDS.some((key) => {
      const value = presentation[key]
      return typeof value === 'string' && value.trim()
    })

    if (presentationStrings || Number.isFinite(presentation.autoPreviewPriority)) {
      return true
    }
  }

  if (entry.templateMeta && typeof entry.templateMeta === 'object') {
    const metaHasValue = TEMPLATE_META_STRING_FIELDS.some((key) => {
      const value = entry.templateMeta[key]
      return typeof value === 'string' && value.trim()
    })

    if (metaHasValue) {
      return true
    }
  }

  const templateStrings = ['templateId', 'templateName', 'template']
  if (templateStrings.some((key) => typeof entry[key] === 'string' && entry[key].trim())) {
    return true
  }

  return false
}

function isMarkedTestOrStale(entry) {
  if (!entry || typeof entry !== 'object') {
    return false
  }

  if (entry.__trusted === true || hasTrustedMetadata(entry)) {
    return false
  }

  if (entry.test === true || entry.isTest === true || entry.testing === true) {
    return true
  }
  if (entry.preview === true || entry.isPreview === true) {
    return true
  }
  if (entry.stale === true || entry.isStale === true || entry.archived === true) {
    return true
  }

  const statusCandidates = [
    entry.status,
    entry.state,
    entry.stage,
    entry.lifecycle,
    entry.lifecycleStatus,
    entry.lifecycleState,
    entry.variant,
    entry.mode,
    entry.phase,
    entry.version
  ]

  for (const candidate of statusCandidates) {
    if (matchesBannedStatus(candidate)) {
      return true
    }
  }

  if (matchesBannedStatus(entry.label) || matchesBannedStatus(entry.type)) {
    return true
  }

  const tagValues = [
    ...normalizeTagList(entry.tags),
    ...normalizeTagList(entry.labels),
    ...normalizeTagList(entry.categories),
    ...normalizeTagList(entry.flags)
  ]

  for (const tag of tagValues) {
    if (matchesBannedStatus(tag)) {
      return true
    }
  }

  return false
}

function isUserSelectedEntry(entry) {
  if (!entry || typeof entry !== 'object') {
    return false
  }

  if (entry.userSelected === true || entry.selected === true || entry.isSelected === true) {
    return true
  }
  if (entry.fromUser === true || entry.manual === true || entry.isManual === true || entry.fromUpload === true) {
    return true
  }

  const type = toLowerSafe(entry.type)
  if (type === 'original_upload' || type === 'original') {
    return true
  }

  const sources = [entry.source, entry.origin, entry.owner, entry.createdBy, entry.generator, entry.mode]
  for (const source of sources) {
    if (USER_STATUS_VALUES.has(toLowerSafe(source))) {
      return true
    }
  }

  const tagValues = [
    ...normalizeTagList(entry.tags),
    ...normalizeTagList(entry.labels),
    ...normalizeTagList(entry.categories),
    ...normalizeTagList(entry.flags)
  ]

  for (const tag of tagValues) {
    if (USER_STATUS_VALUES.has(tag)) {
      return true
    }
  }

  return false
}

function isAutoEnhancedEntry(entry) {
  if (!entry || typeof entry !== 'object') {
    return false
  }

  if (entry.autoEnhanced === true || entry.auto === true || entry.isAuto === true) {
    return true
  }
  if (entry.generated === true || entry.isGenerated === true || entry.aiGenerated === true) {
    return true
  }

  const type = toLowerSafe(entry.type)
  if (
    KNOWN_AUTO_TYPES.has(type) ||
    type.startsWith('version') ||
    type.startsWith('cover_letter') ||
    type.includes('enhanced') ||
    type.endsWith('_resume') ||
    type.endsWith('_cv')
  ) {
    return true
  }

  const sources = [entry.source, entry.origin, entry.generator, entry.mode]
  for (const source of sources) {
    if (AUTO_STATUS_VALUES.has(toLowerSafe(source))) {
      return true
    }
  }

  const tagValues = [
    ...normalizeTagList(entry.tags),
    ...normalizeTagList(entry.labels),
    ...normalizeTagList(entry.categories),
    ...normalizeTagList(entry.flags)
  ]

  for (const tag of tagValues) {
    if (AUTO_STATUS_VALUES.has(tag)) {
      return true
    }
    if (tag.includes('auto') || tag.includes('ai') || tag.includes('enhanced')) {
      return true
    }
  }

  return false
}

function pickFirstString(source = {}, keys = []) {
  for (const key of keys) {
    if (source && typeof source === 'object' && key in source) {
      const value = source[key]
      if (typeof value === 'string' && value.trim()) {
        return value.trim()
      }
    }
  }
  return ''
}

function toFiniteNumber(value) {
  if (value == null) return null
  const number = typeof value === 'number' ? value : Number(value)
  return Number.isFinite(number) ? number : null
}

function normaliseExpiresAt(value) {
  if (!value) return undefined
  if (value instanceof Date) {
    return value.toISOString()
  }
  if (typeof value === 'number' && Number.isFinite(value)) {
    return new Date(value).toISOString()
  }
  if (typeof value === 'string') {
    const trimmed = value.trim()
    return trimmed || undefined
  }
  return undefined
}

function resolveEpoch(value) {
  const finite = toFiniteNumber(value)
  if (finite == null) return undefined
  const milliseconds = Math.abs(finite) < 1e12 ? finite * 1000 : finite
  return new Date(milliseconds).toISOString()
}

function resolveExpiresAt(entry, options = {}, visited = new Set()) {
  if (!entry || typeof entry !== 'object') {
    return normaliseExpiresAt(entry)
  }
  if (visited.has(entry)) {
    return undefined
  }
  visited.add(entry)

  const directIso = pickFirstString(entry, EXPIRES_AT_KEYS)
  if (directIso) {
    const normalized = normaliseExpiresAt(directIso)
    if (normalized) {
      return normalized
    }
  }

  for (const key of EXPIRES_MS_KEYS) {
    if (key in entry) {
      const normalized = resolveEpoch(entry[key])
      if (normalized) {
        return normalized
      }
    }
  }

  for (const key of EXPIRES_EPOCH_KEYS) {
    if (key in entry) {
      const normalized = resolveEpoch(entry[key])
      if (normalized) {
        return normalized
      }
    }
  }

  for (const key of EXPIRES_IN_KEYS) {
    if (key in entry) {
      const seconds = toFiniteNumber(entry[key])
      if (seconds != null) {
        return new Date(Date.now() + seconds * 1000).toISOString()
      }
    }
  }

  const nestedSources = [
    entry.download,
    entry.asset,
    entry.document,
    entry.file,
    entry.link,
    entry.payload,
    entry.value
  ]

  nestedSources.push(
    ...(Array.isArray(entry.urls) ? entry.urls : []),
    ...(Array.isArray(entry.links) ? entry.links : [])
  )

  if (entry.urls && typeof entry.urls === 'object') {
    nestedSources.push(...Object.values(entry.urls))
  }

  if (entry.links && typeof entry.links === 'object') {
    nestedSources.push(...Object.values(entry.links))
  }

  for (const nested of nestedSources) {
    if (!nested) continue
    const nestedExpiry = resolveExpiresAt(nested, options, visited)
    if (nestedExpiry) {
      return nestedExpiry
    }
  }

  if (options.defaultExpiresAt) {
    const normalized = normaliseExpiresAt(options.defaultExpiresAt)
    if (normalized) {
      return normalized
    }
  }

  if (options.defaultExpiresInSeconds != null) {
    const seconds = toFiniteNumber(options.defaultExpiresInSeconds)
    if (seconds != null) {
      return new Date(Date.now() + seconds * 1000).toISOString()
    }
  }

  return undefined
}

function isLikelyUrl(value) {
  if (typeof value !== 'string') return false
  const trimmed = value.trim()
  return /^https?:\/\//i.test(trimmed)
}

function extractUrl(entry, visited = new Set()) {
  if (!entry) return ''
  if (typeof entry === 'string') {
    const trimmed = entry.trim()
    return trimmed && isLikelyUrl(trimmed) ? trimmed : ''
  }
  if (typeof entry !== 'object') {
    return ''
  }
  if (visited.has(entry)) {
    return ''
  }
  visited.add(entry)

  const direct = pickFirstString(entry, URL_KEYS)
  if (direct && isLikelyUrl(direct)) {
    return direct
  }

  const nestedSources = [
    entry.download,
    entry.asset,
    entry.document,
    entry.file,
    entry.payload,
    entry.value
  ]

  nestedSources.push(
    ...(Array.isArray(entry.urls) ? entry.urls : []),
    ...(Array.isArray(entry.links) ? entry.links : [])
  )

  if (entry.urls && typeof entry.urls === 'object') {
    nestedSources.push(...Object.values(entry.urls))
  }

  if (entry.links && typeof entry.links === 'object') {
    nestedSources.push(...Object.values(entry.links))
  }

  for (const nested of nestedSources) {
    if (!nested) continue
    const nestedUrl = extractUrl(nested, visited)
    if (nestedUrl) {
      return nestedUrl
    }
  }

  for (const value of Object.values(entry)) {
    if (typeof value === 'string' && isLikelyUrl(value)) {
      return value.trim()
    }
  }

  return ''
}

function deriveType(entry = {}, fallbackType = '', index = 0) {
  const candidates = [entry.type, entry.name, entry.label, fallbackType]
  for (const candidate of candidates) {
    if (typeof candidate === 'string' && candidate.trim()) {
      return candidate.trim()
    }
  }
  return `file_${index + 1}`
}

function sanitizeStringValue(value) {
  if (typeof value !== 'string') {
    return ''
  }
  const trimmed = value.trim()
  return trimmed
}

function sanitizeTimestampValue(value) {
  if (!value) {
    return ''
  }
  if (value instanceof Date) {
    const time = value.getTime()
    if (Number.isNaN(time)) {
      return ''
    }
    return value.toISOString()
  }
  if (typeof value === 'number') {
    const date = new Date(value)
    if (Number.isNaN(date.getTime())) {
      return ''
    }
    return date.toISOString()
  }
  if (typeof value === 'string') {
    const trimmed = value.trim()
    if (!trimmed) {
      return ''
    }
    const date = new Date(trimmed)
    if (Number.isNaN(date.getTime())) {
      return ''
    }
    return date.toISOString()
  }
  return ''
}

function sanitizeTemplateMeta(meta) {
  if (!meta || typeof meta !== 'object') {
    return undefined
  }
  const sanitized = {}
  TEMPLATE_META_STRING_FIELDS.forEach((key) => {
    const value = meta[key]
    if (typeof value === 'string') {
      const trimmed = value.trim()
      if (trimmed) {
        sanitized[key] = trimmed
      }
    }
  })
  return Object.keys(sanitized).length ? sanitized : undefined
}

function sanitizePresentationMeta(presentation) {
  if (!presentation || typeof presentation !== 'object') {
    return undefined
  }
  const sanitized = {}
  PRESENTATION_STRING_FIELDS.forEach((key) => {
    const value = presentation[key]
    if (typeof value === 'string') {
      const trimmed = value.trim()
      if (trimmed) {
        sanitized[key] = trimmed
      }
    }
  })
  if (Number.isFinite(presentation.autoPreviewPriority)) {
    sanitized.autoPreviewPriority = presentation.autoPreviewPriority
  }
  return Object.keys(sanitized).length ? sanitized : undefined
}

function sanitizeNormalizedEntry(entry, index = 0) {
  if (!entry || typeof entry !== 'object') {
    return null
  }

  const sanitized = {}

  const type = sanitizeStringValue(entry.type) || `file_${index + 1}`
  const url = sanitizeStringValue(entry.url)
  if (!url) {
    return null
  }

  sanitized.type = type
  sanitized.url = url

  PRESERVED_STRING_FIELDS.forEach((key) => {
    const value = sanitizeStringValue(entry[key])
    if (value) {
      sanitized[key] = value
    }
  })

  const text = typeof entry.text === 'string' ? entry.text.trim() : ''
  if (text) {
    sanitized.text = text
  }

  const generatedAt = sanitizeTimestampValue(entry.generatedAt)
  if (generatedAt) {
    sanitized.generatedAt = generatedAt
  }

  const updatedAt = sanitizeTimestampValue(entry.updatedAt)
  if (updatedAt) {
    sanitized.updatedAt = updatedAt
  }

  const expiresAt = sanitizeTimestampValue(entry.expiresAt)
  if (expiresAt) {
    sanitized.expiresAt = expiresAt
  }

  const templateMeta = sanitizeTemplateMeta(entry.templateMeta)
  if (templateMeta) {
    sanitized.templateMeta = templateMeta
  }

  const presentation = sanitizePresentationMeta(entry.presentation)
  if (presentation) {
    sanitized.presentation = presentation
  }

  return sanitized
}

function normaliseOutputFileEntry(entry, index = 0, fallbackType = '', options = {}) {
  if (!entry) return null
  if (typeof entry === 'string') {
    const trimmed = entry.trim()
    if (!trimmed) return null
    return {
      type: fallbackType || `file_${index + 1}`,
      url: trimmed,
    }
  }
  if (typeof entry !== 'object') {
    return null
  }

  const url = extractUrl(entry)
  if (!url) {
    return null
  }

  const normalized = {
    ...entry,
    url,
  }

  if (hasTrustedMetadata(normalized)) {
    normalized.__trusted = true
  }

  const expiresAt = resolveExpiresAt(entry, options)
  if (expiresAt) {
    normalized.expiresAt = expiresAt
  } else if ('expiresAt' in normalized) {
    delete normalized.expiresAt
  }

  if (typeof normalized.text !== 'string' && typeof entry?.download?.text === 'string') {
    normalized.text = entry.download.text
  }

  normalized.type = deriveType(entry, fallbackType, index)

  return normalized
}

function computeRetentionPriority(entry) {
  if (isUserSelectedEntry(entry)) {
    return 0
  }
  if (isAutoEnhancedEntry(entry)) {
    return 1
  }
  return 2
}

function parseTimestampValue(value) {
  if (value == null) return 0
  if (value instanceof Date) {
    const time = value.getTime()
    return Number.isNaN(time) ? 0 : time
  }
  if (typeof value === 'number' && Number.isFinite(value)) {
    return value > 1e12 ? value : value * 1000
  }
  if (typeof value === 'string') {
    const trimmed = value.trim()
    if (!trimmed) return 0
    const numeric = Number(trimmed)
    if (Number.isFinite(numeric)) {
      return numeric > 1e12 ? numeric : numeric * 1000
    }
    const date = new Date(trimmed)
    if (!Number.isNaN(date.getTime())) {
      return date.getTime()
    }
  }
  return 0
}

function buildCandidateMeta(entry, index) {
  return {
    entry,
    index,
    firstIndex: index,
    priority: computeRetentionPriority(entry),
    timestamp:
      parseTimestampValue(entry.generatedAt) ||
      parseTimestampValue(entry.updatedAt) ||
      parseTimestampValue(entry.refreshedAt) ||
      parseTimestampValue(entry.expiresAt) ||
      parseTimestampValue(entry.expires_at)
  }
}

function isBetterCandidate(candidate, existing) {
  if (candidate.priority < existing.priority) {
    return true
  }
  if (candidate.priority > existing.priority) {
    return false
  }
  if (candidate.timestamp > existing.timestamp) {
    return true
  }
  if (candidate.timestamp < existing.timestamp) {
    return false
  }
  return candidate.index > existing.index
}

function dedupePreferredEntries(entries) {
  if (!Array.isArray(entries) || entries.length === 0) {
    return []
  }

  const retentionMap = new Map()

  entries.forEach((entry, index) => {
    if (!entry || typeof entry !== 'object') {
      return
    }
    if (isMarkedTestOrStale(entry)) {
      return
    }

    const candidate = buildCandidateMeta(entry, index)
    if (candidate.priority > 1) {
      return
    }

    const key = toLowerSafe(entry.type) || `file_${index + 1}`
    const existing = retentionMap.get(key)
    if (!existing) {
      retentionMap.set(key, candidate)
      return
    }
    if (isBetterCandidate(candidate, existing)) {
      retentionMap.set(key, { ...candidate, firstIndex: existing.firstIndex })
    } else if (existing.firstIndex > candidate.index) {
      existing.firstIndex = candidate.index
    }
  })

  return Array.from(retentionMap.values())
    .sort((a, b) => a.firstIndex - b.firstIndex)
    .map((item) => item.entry)
}

function finalizeNormalizedEntries(entries) {
  return dedupePreferredEntries(entries)
    .map((entry, index) => sanitizeNormalizedEntry(entry, index))
    .filter(Boolean)
}

export function normalizeOutputFiles(rawInput, options = {}) {
  if (!rawInput) {
    return []
  }

  const normalized = []

  if (Array.isArray(rawInput)) {
    rawInput.forEach((entry, index) => {
      const normalizedEntry = normaliseOutputFileEntry(entry, index, '', options)
      if (normalizedEntry) {
        normalized.push(normalizedEntry)
      }
    })
    return finalizeNormalizedEntries(normalized)
  }

  if (typeof rawInput === 'string') {
    const trimmed = rawInput.trim()
    if (!trimmed) return []
    const sanitized = sanitizeNormalizedEntry({ type: 'file_1', url: trimmed }, 0)
    return sanitized ? [sanitized] : []
  }

  if (typeof rawInput === 'object') {
    Object.entries(rawInput).forEach(([key, value], index) => {
      const normalizedEntry = normaliseOutputFileEntry(value, index, key, options)
      if (normalizedEntry) {
        if (!normalizedEntry.type && typeof key === 'string' && key.trim()) {
          normalizedEntry.type = key.trim()
        }
        normalized.push(normalizedEntry)
      }
    })
  }

  return finalizeNormalizedEntries(normalized)
}

export default normalizeOutputFiles
