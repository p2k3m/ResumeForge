<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="resumeforge-api-base" content="%VITE_API_BASE_URL%" />
    <script>
      ;(function setResumeForgeApiBase() {
        const resolveFallbackApiBase = () => {
          try {
            if (typeof __PUBLISHED_CLOUDFRONT_METADATA__ === 'undefined') {
              return '';
            }

            const metadata =
              __PUBLISHED_CLOUDFRONT_METADATA__ && typeof __PUBLISHED_CLOUDFRONT_METADATA__ === 'object'
                ? __PUBLISHED_CLOUDFRONT_METADATA__
                : null;
            if (!metadata || typeof metadata.cloudfront !== 'object' || !metadata.cloudfront) {
              return '';
            }

            const candidate = metadata.cloudfront.apiGatewayUrl || metadata.cloudfront.url || '';
            return typeof candidate === 'string' ? candidate.trim() : '';
          } catch (error) {
            return '';
          }
        };

        try {
          const meta = document.querySelector('meta[name="resumeforge-api-base"]');
          const metaContent =
            meta && typeof meta.getAttribute === 'function' ? meta.getAttribute('content') || '' : '';
          const normalizedMeta = typeof metaContent === 'string' ? metaContent.trim() : '';

          const existingGlobal =
            typeof window !== 'undefined' && typeof window.__RESUMEFORGE_API_BASE_URL__ === 'string'
              ? window.__RESUMEFORGE_API_BASE_URL__.trim()
              : '';

          if (existingGlobal) {
            if (!normalizedMeta && meta && typeof meta.setAttribute === 'function') {
              meta.setAttribute('content', existingGlobal);
            }
            return;
          }

          let resolved = normalizedMeta;
          if (!resolved || resolved === 'undefined' || resolved === 'null') {
            resolved = resolveFallbackApiBase();
          }

          if (!resolved) {
            return;
          }

          if (typeof window !== 'undefined') {
            window.__RESUMEFORGE_API_BASE_URL__ = resolved;
          }

          if (meta && typeof meta.setAttribute === 'function') {
            meta.setAttribute('content', resolved);
          }
        } catch (error) {
          // Ignore runtime errors caused by constrained environments.
        }
      })();
    </script>
    <title>ResumeForge</title>
    <link rel="stylesheet" href="/src/index.css" />
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #f8fafc;
      }
      #cloudfront-degraded-banner {
        box-sizing: border-box;
        width: min(720px, calc(100% - 2.5rem));
        margin: 2rem auto 0;
        padding: 1.5rem;
        border-radius: 16px;
        border: 1px solid rgba(234, 179, 8, 0.4);
        background: linear-gradient(180deg, rgba(253, 224, 71, 0.3) 0%, rgba(254, 249, 195, 0.45) 100%);
        color: #78350f;
        box-shadow: 0 20px 50px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }
      #cloudfront-degraded-banner[hidden] {
        display: none !important;
      }
      #cloudfront-degraded-banner .cloudfront-degraded__title {
        margin: 0;
        font-size: clamp(1.25rem, 3vw, 1.65rem);
        font-weight: 700;
        color: #92400e;
      }
      #cloudfront-degraded-banner .cloudfront-degraded__body {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.55;
      }
      #cloudfront-degraded-banner a {
        color: #b45309;
        font-weight: 600;
        text-decoration: none;
        word-break: break-all;
      }
      #cloudfront-degraded-banner a:hover,
      #cloudfront-degraded-banner a:focus {
        text-decoration: underline;
      }
      #cloudfront-degraded-banner code {
        font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        background: rgba(254, 240, 138, 0.6);
        padding: 0.2rem 0.45rem;
        border-radius: 6px;
        font-size: 0.9rem;
      }
      #static-asset-warning {
        box-sizing: border-box;
        width: min(720px, calc(100% - 2.5rem));
        margin: 3.5rem auto;
        padding: 1.75rem;
        border-radius: 16px;
        border: 1px solid rgba(220, 38, 38, 0.25);
        background: linear-gradient(180deg, #fff5f5 0%, #fffef9 100%);
        color: #7f1d1d;
        box-shadow: 0 24px 60px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }
      #static-asset-warning[hidden] {
        display: none !important;
      }
      #static-asset-warning .static-asset-warning__title {
        margin: 0;
        font-size: clamp(1.35rem, 3vw, 1.75rem);
        font-weight: 700;
      }
      #static-asset-warning .static-asset-warning__body {
        margin: 0;
        font-size: 1rem;
        line-height: 1.6;
      }
      #static-asset-warning code {
        font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          'Liberation Mono', 'Courier New', monospace;
        background: rgba(255, 255, 255, 0.65);
        padding: 0.2rem 0.45rem;
        border-radius: 6px;
        font-size: 0.95rem;
      }
      @media (prefers-color-scheme: dark) {
        body {
          background: #0f172a;
        }
        #cloudfront-degraded-banner {
          border-color: rgba(234, 179, 8, 0.55);
          background: linear-gradient(180deg, rgba(180, 83, 9, 0.4) 0%, rgba(120, 53, 15, 0.3) 100%);
          color: #fef3c7;
          box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
        }
        #cloudfront-degraded-banner code {
          background: rgba(120, 53, 15, 0.5);
          color: #fef3c7;
        }
        #cloudfront-degraded-banner a {
          color: #fbbf24;
        }
        #static-asset-warning {
          border-color: rgba(248, 113, 113, 0.4);
          background: linear-gradient(180deg, rgba(248, 113, 113, 0.2) 0%, rgba(248, 113, 113, 0.1) 100%);
          color: #fee2e2;
          box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
        }
        #static-asset-warning code {
          background: rgba(15, 23, 42, 0.4);
          color: #fef2f2;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <section
      id="cloudfront-degraded-banner"
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      hidden
      data-visible="false"
    >
      <h1 class="cloudfront-degraded__title">CloudFront is unavailable â€” using API Gateway fallback</h1>
      <p class="cloudfront-degraded__body">
        ResumeForge routed you directly to the API Gateway so you can continue working while the CDN recovers.
      </p>
      <p class="cloudfront-degraded__body" data-cloudfront-domain-wrapper hidden>
        Primary CloudFront domain: <code data-cloudfront-domain></code>
      </p>
      <p class="cloudfront-degraded__body" data-backup-api-wrapper hidden>
        Backup endpoint:
        <a data-backup-api-link href="#" rel="noopener noreferrer" target="_blank">
          <span data-backup-api-text></span>
        </a>
      </p>
      <p class="cloudfront-degraded__body" data-cloudfront-updated-wrapper hidden>
        Metadata last updated at <time data-cloudfront-updated></time>
      </p>
      <input type="hidden" name="resumeforge-backup-api-base" data-backup-api-base value="" />
    </section>
    <div
      id="static-asset-warning"
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      hidden
      data-visible="false"
    >
      <h1 class="static-asset-warning__title">We're having trouble loading ResumeForge</h1>
      <p class="static-asset-warning__body">
        The static assets required to run the portal could not be downloaded. This often happens when the
        CDN is temporarily unavailable or a cached bundle was removed before the page refreshed.
      </p>
      <p class="static-asset-warning__body">
        Please refresh the page in a few minutes. If the issue persists, contact support so we can restore
        access.
      </p>
      <p class="static-asset-warning__body" data-static-asset-source-wrapper hidden>
        Missing file: <code data-static-asset-source></code>
      </p>
    </div>
    <script>
      ;(function () {
        const setBackupInputValue = (value) => {
          const inputs = document.querySelectorAll('input[data-backup-api-base]')
          const nextValue = typeof value === 'string' ? value : ''
          inputs.forEach((input) => {
            if (input && typeof input.setAttribute === 'function') {
              input.value = nextValue
              input.setAttribute('value', nextValue)
            }
          })
        }

        const initialBackupApiBase = (() => {
          try {
            const inputs = document.querySelectorAll('input[data-backup-api-base]')
            for (const input of inputs) {
              if (!input) {
                continue
              }

              if (typeof input.getAttribute === 'function') {
                const attributeValue = input.getAttribute('value')
                if (typeof attributeValue === 'string' && attributeValue.trim()) {
                  return attributeValue.trim()
                }
              }

              if (typeof input.value === 'string' && input.value.trim()) {
                return input.value.trim()
              }
            }
          } catch (error) {
            // Ignore probing failures in constrained environments.
          }

          return ''
        })()

        const inlinePublishedCloudfrontMetadata = (() => {
          try {
            if (typeof __PUBLISHED_CLOUDFRONT_METADATA__ === 'undefined') {
              return null
            }
            return __PUBLISHED_CLOUDFRONT_METADATA__ && typeof __PUBLISHED_CLOUDFRONT_METADATA__ === 'object'
              ? __PUBLISHED_CLOUDFRONT_METADATA__
              : null
          } catch (error) {
            return null
          }
        })()

        if (inlinePublishedCloudfrontMetadata && typeof window !== 'undefined') {
          try {
            const existing = window.__RESUMEFORGE_CLOUDFRONT_METADATA__
            if (!existing || typeof existing !== 'object') {
              window.__RESUMEFORGE_CLOUDFRONT_METADATA__ = inlinePublishedCloudfrontMetadata
            }
          } catch (error) {
            // Ignore inline metadata assignment failures in restricted environments.
          }
        }

        const degradeBanner = document.getElementById('cloudfront-degraded-banner')
        const degradeDomainWrapper = degradeBanner?.querySelector('[data-cloudfront-domain-wrapper]')
        const degradeDomainLabel = degradeBanner?.querySelector('[data-cloudfront-domain]')
        const degradeBackupWrapper = degradeBanner?.querySelector('[data-backup-api-wrapper]')
        const degradeBackupLink = degradeBanner?.querySelector('[data-backup-api-link]')
        const degradeBackupText = degradeBanner?.querySelector('[data-backup-api-text]')
        const degradeUpdatedWrapper = degradeBanner?.querySelector('[data-cloudfront-updated-wrapper]')
        const degradeUpdated = degradeBanner?.querySelector('[data-cloudfront-updated]')

        const revealDegradeBanner = ({ canonicalHost, backupUrl, updatedAt }) => {
          if (!degradeBanner) {
            return
          }

          if (canonicalHost && degradeDomainWrapper && degradeDomainLabel) {
            degradeDomainLabel.textContent = canonicalHost
            degradeDomainWrapper.hidden = false
          }

          if (backupUrl && degradeBackupWrapper && degradeBackupLink && degradeBackupText) {
            degradeBackupLink.href = backupUrl
            degradeBackupText.textContent = backupUrl
            degradeBackupWrapper.hidden = false
          }

          if (updatedAt && degradeUpdated && degradeUpdatedWrapper) {
            degradeUpdated.textContent = updatedAt
            degradeUpdatedWrapper.hidden = false
          }

          const wasVisible = degradeBanner.dataset.visible === 'true'
          if (!wasVisible) {
            degradeBanner.dataset.visible = 'true'
            degradeBanner.hidden = false
          }
        }

        const applyDegradedState = ({ canonicalUrl, backupUrl, updatedAt }) => {
          let canonicalHost = ''
          if (canonicalUrl) {
            try {
              canonicalHost = new URL(canonicalUrl, window.location.href).hostname
            } catch (error) {
              console.warn('Unable to parse CloudFront metadata URL.', error)
            }
          }

          const sanitizedBackup = backupUrl || ''

          if (sanitizedBackup) {
            setBackupInputValue(sanitizedBackup)
          }

          if (degradeBanner) {
            revealDegradeBanner({ canonicalHost, backupUrl: sanitizedBackup, updatedAt })
          }

          try {
            window.__RESUMEFORGE_CLOUDFRONT_DEGRADE__ = {
              canonicalUrl: canonicalUrl || '',
              backupApiGatewayUrl: sanitizedBackup,
              detectedAt: updatedAt || new Date().toISOString()
            }
          } catch (error) {
            console.warn('Unable to record CloudFront fallback metadata on the window.', error)
          }
        }

        const PUBLISHED_CLOUDFRONT_ENDPOINT_PATHS = Object.freeze([
          '/api/published-cloudfront',
          '/api/published-cloudfront.json'
        ])

        const loadPublishedCloudfrontMetadata = async () => {
          if (typeof fetch !== 'function') {
            return null
          }

          let lastError = null
          for (const path of PUBLISHED_CLOUDFRONT_ENDPOINT_PATHS) {
            const endpoints = buildAliasEndpointCandidates(path)
            for (const endpoint of endpoints) {
              if (!endpoint) {
                continue
              }

              try {
                const response = await fetch(endpoint, {
                  method: 'GET',
                  cache: 'no-store',
                  credentials: 'omit'
                })
                if (!response || !response.ok) {
                  continue
                }

                try {
                  const payload = await response.json()
                  if (payload && typeof payload === 'object') {
                    return payload
                  }
                } catch (innerError) {
                  lastError = innerError
                  continue
                }
              } catch (error) {
                lastError = error
              }
            }
          }

          if (lastError) {
            console.warn('Unable to load published CloudFront metadata.', lastError)
          }

          return null
        }

        if (degradeBanner) {
          const host = typeof window.location?.hostname === 'string' ? window.location.hostname : ''
          const onApiGateway = /\.execute-api\.[^.]+\.amazonaws\.com$/i.test(host)

          if (onApiGateway) {
            const fallbackOrigin = typeof window.location?.origin === 'string' ? window.location.origin : ''

            const handleMetadata = (payload) => {
              const canonicalUrl =
                typeof payload?.cloudfront?.url === 'string' && payload.cloudfront.url.trim()
                  ? payload.cloudfront.url.trim()
                  : ''
              const backupUrl =
                typeof payload?.cloudfront?.apiGatewayUrl === 'string' && payload.cloudfront.apiGatewayUrl.trim()
                  ? payload.cloudfront.apiGatewayUrl.trim()
                  : fallbackOrigin
              const updatedAt =
                typeof payload?.cloudfront?.updatedAt === 'string' && payload.cloudfront.updatedAt.trim()
                  ? payload.cloudfront.updatedAt.trim()
                  : ''

              applyDegradedState({ canonicalUrl, backupUrl, updatedAt })
            }

            loadPublishedCloudfrontMetadata().then((data) => handleMetadata(data)).catch((error) => {
              console.warn('Unable to load published CloudFront metadata.', error)
              handleMetadata(null)
            })
          } else if (initialBackupApiBase) {
            setBackupInputValue(initialBackupApiBase)
          }
        }

        const HARD_REFRESH_PARAM = '__rf_refresh'
        const HARD_REFRESH_STORAGE_KEY = '__resumeforge_last_hard_refresh'
        const HARD_REFRESH_MIN_INTERVAL_MS = 5 * 60 * 1000

        try {
          const currentUrl = new URL(window.location.href)
          if (currentUrl.searchParams.has(HARD_REFRESH_PARAM)) {
            currentUrl.searchParams.delete(HARD_REFRESH_PARAM)
            if (typeof window.history?.replaceState === 'function') {
              window.history.replaceState(
                null,
                document.title,
                `${currentUrl.pathname}${currentUrl.search}${currentUrl.hash}`
              )
            }
          }
        } catch (error) {
          // Ignore URL parsing errors in constrained environments.
        }

        const warning = document.getElementById('static-asset-warning')
        if (!warning) {
          return
        }

        const sourceWrapper = warning.querySelector('[data-static-asset-source-wrapper]')
        const sourceLabel = warning.querySelector('[data-static-asset-source]')

        const detectHashedIndexCssPresence = () => {
          try {
            const links = document.querySelectorAll('link[rel~="stylesheet"]')
            for (const link of links) {
              if (!link) {
                continue
              }

              const rawHref =
                typeof link.getAttribute === 'function'
                  ? link.getAttribute('href') || link.href
                  : link.href

              if (!rawHref) {
                continue
              }

              let candidate = String(rawHref).trim()
              if (!candidate) {
                continue
              }

              try {
                const resolved = new URL(candidate, window.location.href)
                candidate = `${resolved.pathname}${resolved.search}`
              } catch (error) {
                // Ignore URL resolution failures and fall back to the raw href.
              }

              candidate = candidate.replace(/[#?].*$/, '')
              candidate = candidate.replace(/^(?:\.\.\/|\.\/)+/, '')
              candidate = candidate.replace(/^\/+/, '')
              candidate = candidate.replace(/\\/g, '/')

              if (/^assets\/index-(?!latest(?:\.|$))[\w.-]+\.css$/i.test(candidate)) {
                return true
              }
            }
          } catch (error) {
            // Ignore stylesheet detection errors in constrained environments.
          }

          return false
        }

        const hasInlineIndexCss = detectHashedIndexCssPresence()
        try {
          if (typeof window !== 'undefined') {
            window.__RESUMEFORGE_HAS_INDEX_CSS__ = hasInlineIndexCss
          }
        } catch (error) {
          // Ignore globals that cannot be set in restricted environments.
        }
        const resolveEffectiveCloudfrontMetadata = () => {
          try {
            const runtime =
              typeof window !== 'undefined' &&
              window.__RESUMEFORGE_CLOUDFRONT_METADATA__ &&
              typeof window.__RESUMEFORGE_CLOUDFRONT_METADATA__ === 'object'
                ? window.__RESUMEFORGE_CLOUDFRONT_METADATA__
                : null

            if (runtime && typeof runtime === 'object') {
              return typeof runtime.cloudfront === 'object' && runtime.cloudfront
                ? runtime.cloudfront
                : runtime
            }
          } catch (error) {
            // Ignore runtime metadata access failures in constrained environments.
          }

          const inlineMetadata = inlinePublishedCloudfrontMetadata
          if (inlineMetadata && typeof inlineMetadata === 'object') {
            return typeof inlineMetadata.cloudfront === 'object' && inlineMetadata.cloudfront
              ? inlineMetadata.cloudfront
              : inlineMetadata
          }

          return null
        }

        const aliasPaths = Object.freeze({
          js: '/assets/index-latest.js',
          css: hasInlineIndexCss ? '/assets/index-latest.css' : ''
        })

        const MANIFEST_ERROR_BACKOFF_MS = 5000
        const manifestState = {
          loaded: false,
          promise: null,
          lastErrorAt: 0,
          candidatesByExtension: { js: [], css: [] }
        }

        const HASHED_INDEX_ASSET_PATTERN = /^(?:\/)?assets\/index-(?!latest(?:\.|$))[\w.-]+\.(?:css|js)$/i

        const appendManifestCandidates = (extension, values) => {
          if (!extension || !Array.isArray(values) || values.length === 0) {
            return
          }

          const normalizedExtension = extension === 'css' ? 'css' : 'js'
          const bucket = Array.isArray(manifestState.candidatesByExtension[normalizedExtension])
            ? manifestState.candidatesByExtension[normalizedExtension]
            : []
          const seen = new Set(bucket)

          values.forEach((candidate) => {
            if (!candidate || seen.has(candidate)) {
              return
            }
            seen.add(candidate)
            bucket.push(candidate)
          })

          manifestState.candidatesByExtension[normalizedExtension] = bucket
        }

        const seedManifestCandidatesFromDom = () => {
          const discovered = []

          const captureCandidate = (rawValue) => {
            const normalized = normalizeManifestCandidate(rawValue)
            if (!normalized || !HASHED_INDEX_ASSET_PATTERN.test(normalized)) {
              return
            }
            discovered.push(normalized)
          }

          try {
            const scriptElements = document.querySelectorAll('script[src]')
            scriptElements.forEach((script) => {
              if (!script) {
                return
              }

              const value =
                typeof script.getAttribute === 'function'
                  ? script.getAttribute('src') || script.src
                  : script.src

              captureCandidate(value)
            })

            const stylesheetElements = document.querySelectorAll('link[rel]')
            stylesheetElements.forEach((link) => {
              if (!link) {
                return
              }

              const rel = typeof link.rel === 'string' ? link.rel.toLowerCase() : ''
              if (!rel.includes('stylesheet')) {
                return
              }

              const value =
                typeof link.getAttribute === 'function'
                  ? link.getAttribute('href') || link.href
                  : link.href

              captureCandidate(value)
            })
          } catch (error) {
            return
          }

          if (!discovered.length) {
            return
          }

          const buckets = categorizeManifestCandidates(discovered)
          appendManifestCandidates('js', buckets.js)
          appendManifestCandidates('css', buckets.css)
        }

        seedManifestCandidatesFromDom()

        const normalizeManifestCandidate = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          let candidate = value.trim()
          if (!candidate) {
            return ''
          }

          candidate = candidate.replace(/[#?].*$/, '')
          candidate = candidate.replace(/^(?:\.\/)+/g, '')
          candidate = candidate.replace(/^(?:\.\.\/)+/g, '')
          candidate = candidate.replace(/^\/+/, '')
          candidate = candidate.replace(/\\/g, '/')

          for (const separator of [',,', ';;']) {
            const metadataIndex = candidate.indexOf(separator)
            if (metadataIndex !== -1) {
              candidate = candidate.slice(0, metadataIndex).trim()
            }
          }

          candidate = candidate.replace(/[,;]+$/, '')

          if (!candidate) {
            return ''
          }

          return candidate.startsWith('/') ? candidate : `/${candidate}`
        }

        const categorizeManifestCandidates = (values) => {
          const buckets = { js: [], css: [] }
          const seen = new Set()

          const append = (normalized) => {
            if (!normalized || seen.has(normalized)) {
              return
            }

            seen.add(normalized)

            if (/\.js$/i.test(normalized)) {
              buckets.js.push(normalized)
            } else if (/\.css$/i.test(normalized)) {
              buckets.css.push(normalized)
            }
          }

          if (Array.isArray(values)) {
            values.forEach((value) => {
              append(normalizeManifestCandidate(value))
            })
          }

          return buckets
        }

        const resolveManifestPayload = (payload) => {
          if (!payload || typeof payload !== 'object') {
            return null
          }

          if (payload.manifest && typeof payload.manifest === 'object') {
            return resolveManifestPayload(payload.manifest)
          }

          if (payload.data && typeof payload.data === 'object') {
            return resolveManifestPayload(payload.data)
          }

          return payload
        }

        const MANIFEST_API_PATH = '/api/static-manifest'

        const ensureManifestCandidatesLoaded = () => {
          if (manifestState.loaded) {
            return manifestState.promise || Promise.resolve(manifestState.candidatesByExtension)
          }

          if (manifestState.promise) {
            return manifestState.promise
          }

          const now = Date.now()
          if (manifestState.lastErrorAt && now - manifestState.lastErrorAt < MANIFEST_ERROR_BACKOFF_MS) {
            return null
          }

          if (typeof fetch !== 'function') {
            manifestState.loaded = true
            return Promise.resolve(manifestState.candidatesByExtension)
          }

          manifestState.promise = (async () => {
            try {
              const endpoints = buildAliasEndpointCandidates(MANIFEST_API_PATH)
              for (const endpoint of endpoints) {
                if (!endpoint) {
                  continue
                }

                let response
                try {
                  response = await fetch(endpoint, {
                    cache: 'no-store',
                    credentials: 'omit'
                  })
                } catch (error) {
                  continue
                }

                if (!response || !response.ok) {
                  continue
                }

                let payload
                try {
                  payload = await response.json()
                } catch (error) {
                  continue
                }

                const manifest = resolveManifestPayload(payload)
                const combined = Array.isArray(manifest?.hashedIndexAssets) && manifest.hashedIndexAssets.length
                  ? manifest.hashedIndexAssets
                  : Array.isArray(manifest?.assets)
                    ? manifest.assets
                    : []

                manifestState.candidatesByExtension = categorizeManifestCandidates(combined)
                manifestState.loaded = true
                manifestState.lastErrorAt = 0
                return manifestState.candidatesByExtension
              }

              manifestState.lastErrorAt = Date.now()
              return manifestState.candidatesByExtension
            } catch (error) {
              manifestState.lastErrorAt = Date.now()
              return manifestState.candidatesByExtension
            } finally {
              manifestState.promise = null
            }
          })()

          return manifestState.promise
        }

        const stripInlineAssetAnnotations = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          let candidate = value.trim()
          if (!candidate) {
            return ''
          }

          const annotationIndex = candidate.search(/[,;]{2}/)
          if (annotationIndex >= 0) {
            candidate = candidate.slice(0, annotationIndex)
          }

          candidate = candidate.replace(/[,;]+$/, '')
          return candidate.trim()
        }

        const normalizeAliasBase = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          const trimmed = value.trim()
          if (!trimmed) {
            return ''
          }

          try {
            const resolved = new URL(trimmed, window.location.href)
            const pathname = resolved.pathname.replace(/\/*$/, '')
            return `${resolved.origin}${pathname}`
          } catch (error) {
            return ''
          }
        }

        const normalizeApiProxyBase = (value) => {
          const normalized = normalizeAliasBase(value)
          if (!normalized) {
            return ''
          }

          try {
            const resolved = new URL(normalized, window.location.href)
            const host = (resolved.hostname || '').toLowerCase()
            if (!host) {
              return ''
            }

            if (/\.s3[.-]/.test(host)) {
              return ''
            }

            if (/\.cloudfront\.net$/.test(host)) {
              const currentHost =
                typeof window?.location?.hostname === 'string'
                  ? window.location.hostname.toLowerCase()
                  : ''

              if (!currentHost || currentHost !== host) {
                return ''
              }
            }
          } catch (error) {
            return ''
          }

          return normalized
        }

        const resolveApiProxyPriority = (value) => {
          if (typeof value !== 'string' || !value.trim()) {
            return 3
          }

          try {
            const resolved = new URL(value, window.location.href)
            const host = (resolved.hostname || '').toLowerCase()
            if (!host) {
              return 3
            }

            if (/\.execute-api\./.test(host)) {
              return 0
            }

            if (/\.cloudfront\.net$/.test(host)) {
              return 1
            }

            if (/\.s3[.-]/.test(host) || host === 's3.amazonaws.com') {
              return 2
            }
          } catch (error) {
            return 3
          }

          return 4
        }

        const normalizeAliasOriginPath = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          const trimmed = value.trim()
          if (!trimmed || trimmed === '/') {
            return ''
          }

          const prefixed = trimmed.startsWith('/') ? trimmed : `/${trimmed}`
          const withoutTrailing = prefixed.replace(/\/+$/, '')
          return withoutTrailing || ''
        }

        const joinAliasUrl = (base, aliasPath) => {
          if (!aliasPath) {
            return ''
          }

          if (!base) {
            return aliasPath
          }

          const normalizedBase = base.replace(/\/*$/, '')
          const normalizedPath = aliasPath.startsWith('/') ? aliasPath : `/${aliasPath}`
          return `${normalizedBase}${normalizedPath}`
        }

        const buildStaticProxyUrl = (base, aliasPath) => {
          if (!aliasPath) {
            return ''
          }

          const normalizedBase = typeof base === 'string' ? base.trim() : ''
          const sanitizedAsset = aliasPath.replace(/^\/+/, '')
          if (!normalizedBase || !sanitizedAsset) {
            return ''
          }

          const baseWithoutSlash = normalizedBase.replace(/\/+$/, '')
          return `${baseWithoutSlash}/api/static-proxy?asset=${encodeURIComponent(sanitizedAsset)}`
        }

        const extractAwsRegionFromUrl = (value) => {
          if (typeof value !== 'string') {
            return ''
          }

          const trimmed = value.trim()
          if (!trimmed) {
            return ''
          }

          try {
            const resolved = new URL(trimmed, window.location.href)
            const host = (resolved.hostname || '').toLowerCase()
            if (!host) {
              return ''
            }

            const executeMatch = host.match(/^[^.]+\.execute-api\.([a-z0-9-]+)\.amazonaws\.com$/)
            if (executeMatch && executeMatch[1]) {
              return executeMatch[1]
            }

            const s3WebsiteMatch = host.match(/\.s3[.-]website[.-]([a-z0-9-]+)\.amazonaws\.com$/)
            if (s3WebsiteMatch && s3WebsiteMatch[1]) {
              return s3WebsiteMatch[1]
            }

            const s3Match = host.match(/\.s3[.-]([a-z0-9-]+)\.amazonaws\.com$/)
            if (s3Match && s3Match[1]) {
              return s3Match[1]
            }

            const segments = host.split('.')
            for (const segment of segments) {
              if (/^[a-z]{2}-[a-z0-9-]+-[0-9]+$/.test(segment)) {
                return segment
              }
            }
          } catch (error) {
            return ''
          }

          return ''
        }

        const buildS3BaseCandidates = (bucket, regions = []) => {
          if (typeof bucket !== 'string') {
            return []
          }

          const trimmedBucket = bucket.trim()
          if (!trimmedBucket) {
            return []
          }

          const normalizedBucket = trimmedBucket
          const bases = []
          const seen = new Set()

          const addBase = (candidate) => {
            if (!candidate || seen.has(candidate)) {
              return
            }
            seen.add(candidate)
            bases.push(candidate)
          }

          addBase(`https://${normalizedBucket}.s3.amazonaws.com`)

          if (Array.isArray(regions)) {
            regions.forEach((regionValue) => {
              if (!regionValue) {
                return
              }

              const region = String(regionValue).trim().toLowerCase()
              if (!region) {
                return
              }

              addBase(`https://${normalizedBucket}.s3.${region}.amazonaws.com`)
              addBase(`https://${normalizedBucket}.s3-${region}.amazonaws.com`)
              addBase(`https://${normalizedBucket}.s3-website.${region}.amazonaws.com`)
              addBase(`https://${normalizedBucket}.s3-website-${region}.amazonaws.com`)
              addBase(`https://s3.${region}.amazonaws.com/${normalizedBucket}`)
              addBase(`https://s3-${region}.amazonaws.com/${normalizedBucket}`)
            })
          }

          return bases
        }

        const resolveAliasBaseCandidates = () => {
          const candidates = []
          const seen = new Set()

          const addCandidate = (raw) => {
            const normalized = normalizeAliasBase(raw)
            if (!normalized || seen.has(normalized)) {
              return
            }
            seen.add(normalized)
            candidates.push(normalized)
          }

          try {
            const explicitGlobal =
              typeof window.__RESUMEFORGE_API_BASE_URL__ === 'string'
                ? window.__RESUMEFORGE_API_BASE_URL__.trim()
                : ''
            if (explicitGlobal) {
              addCandidate(explicitGlobal)
            }
          } catch (error) {
            // Ignore global override parsing issues.
          }

          try {
            const meta = document.querySelector('meta[name="resumeforge-api-base"]')
            if (meta && typeof meta.getAttribute === 'function') {
              addCandidate(meta.getAttribute('content'))
            }
          } catch (error) {
            // Ignore metadata parsing errors.
          }

          try {
            const inputs = document.querySelectorAll('input[data-backup-api-base]')
            inputs.forEach((input) => {
              if (input) {
                const value =
                  typeof input.value === 'string'
                    ? input.value
                    : typeof input.getAttribute === 'function'
                      ? input.getAttribute('value')
                      : ''
                addCandidate(value)
              }
            })
          } catch (error) {
            // Ignore backup input parsing errors.
          }

          addCandidate(window.location.origin || '')

          // Always include an empty base so we eventually retry the alias path as-is.
          candidates.push('')

          return candidates
        }

        const aliasBaseCandidates = (() => {
          const candidates = resolveAliasBaseCandidates()

          const addCandidate = (value) => {
            if (!value) {
              return
            }

            const normalized = normalizeAliasBase(value)
            if (!normalized) {
              return
            }

            if (!candidates.includes(normalized)) {
              candidates.unshift(normalized)
            }
          }

          const extractApiGatewayUrl = (metadata) =>
            metadata && typeof metadata === 'object'
              ? metadata.apiGatewayUrl || metadata.url || ''
              : ''

          const inlineApiBase = extractApiGatewayUrl(inlinePublishedCloudfrontMetadata?.cloudfront)
          if (inlineApiBase) {
            addCandidate(inlineApiBase)
          }

          try {
            const runtimeMetadata = window.__RESUMEFORGE_CLOUDFRONT_METADATA__
            const runtimeApiBase = extractApiGatewayUrl(runtimeMetadata?.cloudfront)
            if (runtimeApiBase) {
              addCandidate(runtimeApiBase)
            }
          } catch (error) {
            // Ignore runtime metadata access errors in constrained environments.
          }

          return candidates
        })()
        const aliasBaseSeen = new Set(aliasBaseCandidates)
        const apiProxyCandidates = []
        const apiProxySeen = new Set()

        const addApiProxyCandidate = (value) => {
          const normalized = normalizeApiProxyBase(value)
          if (!normalized || apiProxySeen.has(normalized)) {
            return false
          }

          apiProxySeen.add(normalized)
          const priority = resolveApiProxyPriority(normalized)
          const insertIndex = apiProxyCandidates.findIndex(
            (candidate) => resolveApiProxyPriority(candidate) > priority
          )

          if (insertIndex === -1) {
            apiProxyCandidates.push(normalized)
          } else {
            apiProxyCandidates.splice(insertIndex, 0, normalized)
          }

          return true
        }

        aliasBaseCandidates.forEach((candidate) => {
          addApiProxyCandidate(candidate)
        })

        try {
          if (typeof window !== 'undefined') {
            const explicitApiBase =
              typeof window.__RESUMEFORGE_API_BASE_URL__ === 'string'
                ? window.__RESUMEFORGE_API_BASE_URL__.trim()
                : ''

            if (explicitApiBase) {
              addApiProxyCandidate(explicitApiBase)
            }
          }
        } catch (error) {
          // Ignore global API base injection failures.
        }

        try {
          ensureManifestCandidatesLoaded()
        } catch (error) {
          // Ignore manifest prefetch failures in constrained environments.
        }

        const addAliasBaseCandidate = (value, options = {}) => {
          const normalized = normalizeAliasBase(value)
          if (!normalized) {
            return false
          }

          const shouldPrepend = Boolean(options && options.prepend)

          if (aliasBaseSeen.has(normalized)) {
            if (!shouldPrepend) {
              return false
            }

            const existingIndex = aliasBaseCandidates.indexOf(normalized)
            if (existingIndex <= 0) {
              addApiProxyCandidate(normalized)
              return existingIndex === 0
            }

            aliasBaseCandidates.splice(existingIndex, 1)
            aliasBaseCandidates.unshift(normalized)
            addApiProxyCandidate(normalized)
            return true
          }

          aliasBaseSeen.add(normalized)
          if (shouldPrepend) {
            aliasBaseCandidates.unshift(normalized)
          } else {
            aliasBaseCandidates.push(normalized)
          }
          addApiProxyCandidate(normalized)
          return true
        }

        const shouldAppendOriginPathToBase = (candidate, originPath) => {
          if (!candidate || !originPath) {
            return false
          }

          try {
            const resolved = new URL(candidate, window.location.href)
            const host = (resolved.hostname || '').toLowerCase()
            if (!host) {
              return false
            }

            if (/^(?:s3[.-]|s3$)/.test(host)) {
              return true
            }

            if (/\.s3[.-]/.test(host)) {
              return true
            }

            if (host === 's3.amazonaws.com') {
              return true
            }

            if (/\.amazonaws\.com$/.test(host)) {
              if (host.startsWith('s3-') || host.startsWith('s3.')) {
                return true
              }
              if (host.includes('.s3-website.')) {
                return true
              }
              if (host.includes('.s3-website-')) {
                return true
              }
            }
          } catch (error) {
            return false
          }

          return false
        }

        const applyAliasMetadataCandidates = (rawMetadata) => {
          if (!rawMetadata || typeof rawMetadata !== 'object') {
            return false
          }

          const metadata =
            rawMetadata && typeof rawMetadata.cloudfront === 'object'
              ? rawMetadata.cloudfront
              : rawMetadata

          if (!metadata || typeof metadata !== 'object') {
            return false
          }

          const originPath = normalizeAliasOriginPath(metadata.originPath)
          const regionHints = new Set()

          const addRegionHint = (value) => {
            if (!value) {
              return
            }
            const normalized = String(value).trim().toLowerCase()
            if (normalized) {
              regionHints.add(normalized)
            }
          }

          addRegionHint(extractAwsRegionFromUrl(metadata.apiGatewayUrl))
          addRegionHint(extractAwsRegionFromUrl(metadata.url))
          addRegionHint(metadata.originRegion)

          const bucketBases = buildS3BaseCandidates(
            typeof metadata.originBucket === 'string' ? metadata.originBucket : '',
            Array.from(regionHints),
          )

          let added = false

          const applyCandidate = (
            candidate,
            { prioritize = false, allowAlias = true, allowProxy = true } = {},
          ) => {
            if (!candidate) {
              return
            }

            if (allowProxy) {
              addApiProxyCandidate(candidate)
            }

            if (allowAlias) {
              if (addAliasBaseCandidate(candidate, { prepend: prioritize })) {
                added = true
              }

              if (shouldAppendOriginPathToBase(candidate, originPath)) {
                if (addAliasBaseCandidate(joinAliasUrl(candidate, originPath), { prepend: prioritize })) {
                  added = true
                }
              }
            }
          }

          const directCandidates = []
          if (typeof metadata.apiGatewayUrl === 'string') {
            directCandidates.push({
              value: metadata.apiGatewayUrl,
              prioritize: true,
              allowAlias: false,
              allowProxy: true,
            })
          }
          if (typeof metadata.url === 'string') {
            directCandidates.push({ value: metadata.url, prioritize: false })
          }

          directCandidates.forEach((entry) =>
            applyCandidate(entry?.value, {
              prioritize: Boolean(entry?.prioritize),
              allowAlias: entry?.allowAlias !== false,
              allowProxy: entry?.allowProxy !== false,
            }),
          )
          bucketBases.forEach((candidate) => applyCandidate(candidate))

          if (originPath && addAliasBaseCandidate(joinAliasUrl('', originPath))) {
            added = true
          }

          return added
        }

        let aliasMetadataLoaded = false
        let aliasMetadataPromise = null

        try {
          if (
            typeof window !== 'undefined' &&
            window.__RESUMEFORGE_CLOUDFRONT_METADATA__ &&
            applyAliasMetadataCandidates(window.__RESUMEFORGE_CLOUDFRONT_METADATA__)
          ) {
            aliasMetadataLoaded = true
          }
        } catch (error) {
          // Ignore inline metadata parsing failures and fall back to runtime loading.
        }

        function buildAliasEndpointCandidates(path) {
          const endpoints = []
          const seen = new Set()

          const append = (value) => {
            if (typeof value !== 'string') {
              return
            }

            const normalized = value.trim()
            if (!normalized || seen.has(normalized)) {
              return
            }

            seen.add(normalized)
            endpoints.push(normalized)
          }

          append(path)

          aliasBaseCandidates.forEach((base) => {
            if (!base) {
              return
            }

            append(joinAliasUrl(base, path))
          })

          return endpoints
        }

        const buildMetadataEndpointCandidates = () => {
          const endpoints = []
          const seen = new Set()

          const append = (candidate) => {
            if (!candidate || seen.has(candidate)) {
              return
            }
            seen.add(candidate)
            endpoints.push(candidate)
          }

          PUBLISHED_CLOUDFRONT_ENDPOINT_PATHS.forEach((path) => {
            const list = buildAliasEndpointCandidates(path)
            list.forEach(append)
          })

          return endpoints
        }

        const ensureAliasMetadataLoaded = () => {
          if (aliasMetadataLoaded) {
            return aliasMetadataPromise || Promise.resolve(false)
          }

          if (aliasMetadataPromise) {
            return aliasMetadataPromise
          }

          aliasMetadataPromise = (async () => {
            try {
              if (typeof fetch !== 'function') {
                return false
              }

              const endpoints = buildMetadataEndpointCandidates()
              for (const endpoint of endpoints) {
                if (!endpoint) {
                  continue
                }

                let response
                try {
                  response = await fetch(endpoint, {
                    cache: 'no-store',
                    credentials: 'omit'
                  })
                } catch (error) {
                  continue
                }

                if (!response || !response.ok) {
                  continue
                }

                let payload
                try {
                  payload = await response.json()
                } catch (error) {
                  continue
                }

                try {
                  if (typeof window !== 'undefined') {
                    window.__RESUMEFORGE_CLOUDFRONT_METADATA__ = payload
                  }
                } catch (error) {
                  // Ignore global assignment errors.
                }

                if (applyAliasMetadataCandidates(payload)) {
                  return true
                }
              }

              return false
            } catch (error) {
              return false
            } finally {
              aliasMetadataLoaded = true
            }
          })().finally(() => {
            aliasMetadataPromise = null
          })

          return aliasMetadataPromise
        }

        const buildAliasUrlForAttempt = (aliasPath, attemptIndex) => {
          if (typeof attemptIndex !== 'number' || attemptIndex < 0) {
            return { url: aliasPath, base: '' }
          }

          const base = aliasBaseCandidates[attemptIndex] ?? ''
          const url = joinAliasUrl(base, aliasPath)
          return { url, base }
        }

        const appendCacheBustParam = (source) => {
          if (!source) {
            return ''
          }

          try {
            const parsed = new URL(source, window.location.href)
            parsed.searchParams.set('__rf_retry', Date.now().toString(36))
            return parsed.href
          } catch (error) {
            const separator = source.includes('?') ? '&' : '?'
            return `${source}${separator}__rf_retry=${Date.now().toString(36)}`
          }
        }

        const attemptCacheBustingReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          if (element.dataset?.resumeforgeAssetRetry === 'true') {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const originalSource = describeSource(element)
          if (!originalSource) {
            return false
          }

          const retrySource = appendCacheBustParam(originalSource)
          if (!retrySource) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const replacement = element.cloneNode(true)

          if (isStylesheet) {
            replacement.href = retrySource
          } else {
            replacement.src = retrySource
          }

          replacement.setAttribute('data-src', retrySource)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeOriginalSource = originalSource

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeOriginalSource = originalSource

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset with cache bust parameter.', {
              source: originalSource,
              retry: retrySource
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        let apiFallbackRedirectScheduled = false

        const gatherApiFallbackBases = () => {
          const bases = []
          const seen = new Set()

          const appendBase = (candidate) => {
            if (!candidate) {
              return
            }

            const normalized = normalizeAliasBase(candidate)
            if (!normalized) {
              return
            }

            try {
              const resolved = new URL(normalized, window.location.href)
              const currentHost = typeof window.location?.hostname === 'string'
                ? window.location.hostname.toLowerCase()
                : ''
              const resolvedHost = (resolved.hostname || '').toLowerCase()
              if (currentHost && resolvedHost && currentHost === resolvedHost) {
                return
              }
            } catch (error) {
              return
            }

            if (seen.has(normalized)) {
              return
            }

            seen.add(normalized)
            bases.push(normalized)
          }

          const inlineApiBase = inlinePublishedCloudfrontMetadata?.cloudfront?.apiGatewayUrl
          if (inlineApiBase) {
            appendBase(inlineApiBase)
          }

          try {
            const runtimeMetadata = window.__RESUMEFORGE_CLOUDFRONT_METADATA__
            if (runtimeMetadata?.cloudfront?.apiGatewayUrl) {
              appendBase(runtimeMetadata.cloudfront.apiGatewayUrl)
            }
          } catch (error) {
            // Ignore runtime metadata access errors.
          }

          aliasBaseCandidates.forEach(appendBase)
          apiProxyCandidates.forEach(appendBase)

          return bases
        }

        const buildApiFallbackUrl = (base) => {
          if (!base) {
            return ''
          }

          try {
            const path = `${window.location.pathname || '/'}`
            const suffix = `${window.location.search || ''}${window.location.hash || ''}`
            return new URL(`${path}${suffix}`, base).toString()
          } catch (error) {
            return ''
          }
        }

        const appendFallbackRedirectParams = (url) => {
          if (!url) {
            return ''
          }

          try {
            const parsed = new URL(url)
            parsed.searchParams.set('__rf_origin', 'cdn-fallback')
            parsed.searchParams.set('__rf_ts', Date.now().toString(36))
            return parsed.toString()
          } catch (error) {
            const separator = url.includes('?') ? '&' : '?'
            return `${url}${separator}__rf_origin=cdn-fallback&__rf_ts=${Date.now().toString(36)}`
          }
        }

        const scheduleApiFallbackRedirect = (reason) => {
          if (apiFallbackRedirectScheduled) {
            return false
          }

          const host = typeof window.location?.hostname === 'string' ? window.location.hostname : ''
          if (/\.execute-api\./i.test(host)) {
            return false
          }

          const bases = gatherApiFallbackBases()
          if (!bases.length) {
            return false
          }

          const target = appendFallbackRedirectParams(buildApiFallbackUrl(bases[0]))
          if (!target) {
            return false
          }

          apiFallbackRedirectScheduled = true

          try {
            console.warn('Redirecting ResumeForge to API fallback due to static asset failure.', {
              source: reason || '',
              target
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          window.setTimeout(() => {
            try {
              recordHardRefreshAttempt()
            } catch (error) {
              // Ignore storage errors when recording refresh attempts.
            }

            try {
              window.location.assign(target)
            } catch (error) {
              window.location.href = target
            }
          }, 750)

          return true
        }

        const logFailure = (sourceText) => {
          if (sourceText) {
            console.error('ResumeForge static asset failed to load.', { source: sourceText })
          } else {
            console.error('ResumeForge static asset failed to load.')
          }

          scheduleApiFallbackRedirect(sourceText)
        }

        const recordHardRefreshAttempt = () => {
          try {
            const storage = window.sessionStorage || window.localStorage
            if (!storage) {
              return
            }

            storage.setItem(
              HARD_REFRESH_STORAGE_KEY,
              Date.now().toString()
            )
          } catch (error) {
            // Ignore storage errors (private mode, etc.)
          }
        }

        const shouldAttemptHardRefresh = () => {
          try {
            const storage = window.sessionStorage || window.localStorage
            if (!storage) {
              return true
            }

            const rawTimestamp = storage.getItem(HARD_REFRESH_STORAGE_KEY)
            if (!rawTimestamp) {
              return true
            }

            const parsed = Number.parseInt(rawTimestamp, 10)
            if (!Number.isFinite(parsed)) {
              return true
            }

            return Date.now() - parsed >= HARD_REFRESH_MIN_INTERVAL_MS
          } catch (error) {
            return true
          }
        }

        const attemptHardRefresh = () => {
          if (!shouldAttemptHardRefresh()) {
            return false
          }

          try {
            const current = new URL(window.location.href)
            if (!current.searchParams.has(HARD_REFRESH_PARAM)) {
              current.searchParams.set(
                HARD_REFRESH_PARAM,
                Date.now().toString(36)
              )
            } else {
              current.searchParams.set(
                HARD_REFRESH_PARAM,
                Date.now().toString(36)
              )
            }

            recordHardRefreshAttempt()
            window.location.replace(current.href)
            return true
          } catch (error) {
            try {
              recordHardRefreshAttempt()
              window.location.reload()
              return true
            } catch (innerError) {
              return false
            }
          }
        }

        const revealWarning = (sourceText) => {
          if (sourceText && sourceLabel && sourceWrapper) {
            sourceLabel.textContent = sourceText
            sourceWrapper.hidden = false
          }

          const wasVisible = warning.dataset.visible === 'true'
          if (!wasVisible) {
            warning.dataset.visible = 'true'
            warning.hidden = false
          }
          return wasVisible
        }

        const describeSource = (element) => {
          if (!element) {
            return ''
          }

          const originalDatasetSource =
            typeof element.dataset?.resumeforgeOriginalSource === 'string'
              ? element.dataset.resumeforgeOriginalSource
              : ''

          const rawSource =
            originalDatasetSource ||
            (typeof element.getAttribute === 'function' && element.getAttribute('data-src')) ||
            element.src ||
            element.href ||
            ''

          if (!rawSource) {
            return ''
          }

          try {
            const resolved = new URL(rawSource, window.location.href)
            if (resolved.origin === window.location.origin) {
              return `${resolved.pathname}${resolved.search}`
            }
            return resolved.href
          } catch (error) {
            return rawSource
          }
        }

        const attemptApiGatewayAssetReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          if (!apiProxyCandidates.length) {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const aliasPath = isScript ? aliasPaths.js : aliasPaths.css
          const originalSource = describeSource(element)
          const normalizedSource = (() => {
            if (!originalSource) {
              return ''
            }

            let candidate = stripInlineAssetAnnotations(String(originalSource).trim())
            if (!candidate) {
              return ''
            }

            try {
              const resolved = new URL(candidate, window.location.href)
              candidate =
                resolved.origin === window.location.origin
                  ? `${resolved.pathname}${resolved.search}`
                  : resolved.href
            } catch (error) {
              // Ignore resolution failures and continue with the raw candidate.
            }

            candidate = candidate.replace(/[#?].*$/, '')
            candidate = candidate.replace(/^(?:\.\.\/|\.\/)+/, '')
            candidate = candidate.replace(/^\/+/, '')
            candidate = candidate.replace(/\\/g, '/')
            if (!candidate) {
              return ''
            }

            if (/^[a-z]+:/i.test(candidate)) {
              return candidate
            }

            return candidate.startsWith('/') ? candidate : `/${candidate}`
          })()

          const candidateAssets = []
          if (normalizedSource && !/^[a-z]+:/i.test(normalizedSource)) {
            candidateAssets.push(normalizedSource)
          }
          if (aliasPath && !candidateAssets.includes(aliasPath)) {
            candidateAssets.push(aliasPath)
          }

          if (!candidateAssets.length) {
            return false
          }

          const rawAttempt = element.dataset?.resumeforgeApiAttempt || '0'
          let attemptIndex = Number.parseInt(rawAttempt, 10)
          if (!Number.isFinite(attemptIndex) || attemptIndex < 0) {
            attemptIndex = 0
          }

          const totalCombinations = candidateAssets.length * apiProxyCandidates.length
          let nextPointer = attemptIndex
          let selectedUrl = ''
          let selectedAsset = ''
          let selectedBase = ''

          while (nextPointer < totalCombinations) {
            const assetIndex = Math.floor(nextPointer / apiProxyCandidates.length)
            const baseIndex = nextPointer % apiProxyCandidates.length
            const assetCandidate = candidateAssets[assetIndex]
            const baseCandidate = apiProxyCandidates[baseIndex]
            const joined = joinAliasUrl(baseCandidate, assetCandidate)
            nextPointer += 1

            if (joined) {
              selectedUrl = joined
              selectedAsset = assetCandidate
              selectedBase = baseCandidate
              break
            }
          }

          element.dataset.resumeforgeApiAttempt = String(nextPointer)

          if (!selectedUrl) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const replacement = element.cloneNode(true)
          const cacheBustedUrl = appendCacheBustParam(selectedUrl)
          const effectiveUrl = cacheBustedUrl || selectedUrl

          if (isStylesheet) {
            replacement.href = effectiveUrl
          } else {
            replacement.src = effectiveUrl
          }

          replacement.setAttribute('data-src', effectiveUrl)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeAssetApi = 'true'
          replacement.dataset.resumeforgeApiAttempt = String(nextPointer)
          if (selectedAsset) {
            replacement.dataset.resumeforgeApiAsset = selectedAsset
          }
          if (selectedBase) {
            replacement.dataset.resumeforgeApiBase = selectedBase
          }
          if (originalSource) {
            replacement.dataset.resumeforgeOriginalSource = originalSource
          }

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeAssetApi = 'true'
          element.dataset.resumeforgeApiAttempt = String(nextPointer)
          if (selectedAsset && !element.dataset.resumeforgeApiAsset) {
            element.dataset.resumeforgeApiAsset = selectedAsset
          }
          if (selectedBase && !element.dataset.resumeforgeApiBase) {
            element.dataset.resumeforgeApiBase = selectedBase
          }
          if (originalSource && !element.dataset.resumeforgeOriginalSource) {
            element.dataset.resumeforgeOriginalSource = originalSource
          }

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset via API origin fallback.', {
              source: originalSource || '',
              target: effectiveUrl,
              base: selectedBase || '',
              asset: selectedAsset || ''
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        const attemptStaticProxyReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          if (!apiProxyCandidates.length) {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const rawAttempt = element.dataset?.resumeforgeProxyAttempt || '0'
          let attemptIndex = Number.parseInt(rawAttempt, 10)
          if (!Number.isFinite(attemptIndex) || attemptIndex < 0) {
            attemptIndex = 0
          }

          const originalSource = describeSource(element)
          const normalizedSource = (() => {
            if (!originalSource) {
              return ''
            }

            let candidate = stripInlineAssetAnnotations(String(originalSource).trim())
            if (!candidate) {
              return ''
            }

            try {
              const resolved = new URL(candidate, window.location.href)
              candidate =
                resolved.origin === window.location.origin
                  ? `${resolved.pathname}${resolved.search}`
                  : resolved.href
            } catch (error) {
              // Ignore URL parsing failures and continue with the raw candidate.
            }

            candidate = candidate.replace(/[#?].*$/, '')
            candidate = candidate.replace(/^(?:\.\.\/|\.\/)+/, '')
            candidate = candidate.replace(/^\/+/, '')
            candidate = candidate.replace(/\\/g, '/')
            if (!candidate) {
              return ''
            }

            if (/^[a-z]+:/i.test(candidate)) {
              return candidate
            }

            return candidate.startsWith('/') ? candidate : `/${candidate}`
          })()

          const aliasPath = isScript ? aliasPaths.js : aliasPaths.css
          if (!aliasPath && !normalizedSource) {
            return false
          }

          const preferredAssetPath = (() => {
            if (normalizedSource && HASHED_INDEX_ASSET_PATTERN.test(normalizedSource)) {
              return normalizedSource
            }

            return aliasPath || ''
          })()

          if (!preferredAssetPath) {
            return false
          }

          const candidateAssets = []
          if (preferredAssetPath) {
            candidateAssets.push(preferredAssetPath)
          }
          if (aliasPath && aliasPath !== preferredAssetPath) {
            candidateAssets.push(aliasPath)
          }

          if (!candidateAssets.length || apiProxyCandidates.length === 0) {
            return false
          }

          const totalCombinations = candidateAssets.length * apiProxyCandidates.length
          let attemptPointer = attemptIndex
          let selectedUrl = ''
          let selectedAsset = ''
          let selectedBase = ''

          if (!Number.isFinite(attemptPointer) || attemptPointer < 0) {
            attemptPointer = 0
          }

          let nextPointer = attemptPointer

          while (nextPointer < totalCombinations) {
            const assetIndex = Math.floor(nextPointer / apiProxyCandidates.length)
            const baseIndex = nextPointer % apiProxyCandidates.length
            const assetCandidate = candidateAssets[assetIndex]
            const baseCandidate = apiProxyCandidates[baseIndex]
            const proxyUrl = buildStaticProxyUrl(baseCandidate, assetCandidate)
            nextPointer += 1

            if (proxyUrl) {
              selectedUrl = proxyUrl
              selectedAsset = assetCandidate
              selectedBase = baseCandidate
              break
            }
          }

          element.dataset.resumeforgeProxyAttempt = String(nextPointer)

          if (!selectedUrl) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const replacement = element.cloneNode(true)

          if (isStylesheet) {
            replacement.href = selectedUrl
          } else {
            replacement.src = selectedUrl
          }

          replacement.setAttribute('data-src', selectedUrl)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeAssetProxy = 'true'
          replacement.dataset.resumeforgeProxyAttempt = String(nextPointer)
          if (selectedAsset) {
            replacement.dataset.resumeforgeProxyAsset = selectedAsset
          }
          if (selectedBase) {
            replacement.dataset.resumeforgeProxyBase = selectedBase
          }
          if (originalSource) {
            replacement.dataset.resumeforgeOriginalSource = originalSource
          }

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeAssetProxy = 'true'
          element.dataset.resumeforgeProxyAttempt = String(nextPointer)
          if (selectedAsset && !element.dataset.resumeforgeProxyAsset) {
            element.dataset.resumeforgeProxyAsset = selectedAsset
          }
          if (selectedBase && !element.dataset.resumeforgeProxyBase) {
            element.dataset.resumeforgeProxyBase = selectedBase
          }
          if (originalSource && !element.dataset.resumeforgeOriginalSource) {
            element.dataset.resumeforgeOriginalSource = originalSource
          }

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset via API proxy fallback.', {
              source: originalSource || '',
              proxy: selectedUrl,
              asset: selectedAsset || '',
              base: selectedBase || ''
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        const attemptOriginPrefixedReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          const metadata = resolveEffectiveCloudfrontMetadata()
          const originPath = normalizeAliasOriginPath(metadata?.originPath)
          if (!originPath) {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const dataset = element.dataset || {}
          if (dataset.resumeforgeOriginPrefixed === 'true') {
            return false
          }

          const originalSource = describeSource(element)
          const normalizedSource = (() => {
            if (!originalSource) {
              return ''
            }

            let candidate = stripInlineAssetAnnotations(String(originalSource).trim())
            if (!candidate) {
              return ''
            }

            try {
              const resolved = new URL(candidate, window.location.href)
              if (resolved.origin === window.location.origin) {
                candidate = `${resolved.pathname}${resolved.search}`
              } else {
                candidate = resolved.href
              }
            } catch (error) {
              // Ignore URL resolution failures and continue with the raw candidate.
            }

            if (/^[a-z]+:/i.test(candidate)) {
              return ''
            }

            candidate = candidate.replace(/[#?].*$/, '')
            candidate = candidate.replace(/^(?:\.\.\/|\.\/)+/, '')
            candidate = candidate.replace(/^\/+/, '')
            candidate = candidate.replace(/\\/g, '/')
            return candidate
          })()

          const preferredAsset = normalizedSource
            ? `/${normalizedSource}`
            : isScript
              ? aliasPaths.js
              : aliasPaths.css

          if (!preferredAsset) {
            return false
          }

          if (preferredAsset.startsWith(`${originPath}/`) || preferredAsset === originPath) {
            return false
          }

          const fallbackUrl = joinAliasUrl(originPath, preferredAsset)
          if (!fallbackUrl) {
            return false
          }

          const replacement = element.cloneNode(true)
          if (isStylesheet) {
            replacement.href = fallbackUrl
          } else {
            replacement.src = fallbackUrl
          }

          replacement.setAttribute('data-src', fallbackUrl)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeOriginPrefixed = 'true'
          if (originalSource) {
            replacement.dataset.resumeforgeOriginalSource = originalSource
          }

          dataset.resumeforgeAssetRetry = 'true'
          dataset.resumeforgeOriginPrefixed = 'true'
          if (originalSource && !dataset.resumeforgeOriginalSource) {
            dataset.resumeforgeOriginalSource = originalSource
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset via origin path fallback.', {
              source: originalSource || '',
              originPath,
              asset: preferredAsset
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        const attemptProxyOrAliasReload = (element) => {
          if (attemptApiGatewayAssetReload(element)) {
            return true
          }

          if (attemptStaticProxyReload(element)) {
            return true
          }

          if (attemptDirectS3Reload(element)) {
            return true
          }

          if (attemptOriginPrefixedReload(element)) {
            return true
          }

          return attemptAliasReload(element)
        }

        const attemptDirectS3Reload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          const metadata = resolveEffectiveCloudfrontMetadata()
          if (!metadata) {
            return false
          }

          const bucket =
            typeof metadata.originBucket === 'string' && metadata.originBucket.trim()
              ? metadata.originBucket.trim()
              : ''
          if (!bucket) {
            return false
          }

          const regionHints = new Set()
          const addRegionHint = (value) => {
            if (!value) {
              return
            }
            const normalized = String(value).trim().toLowerCase()
            if (normalized) {
              regionHints.add(normalized)
            }
          }

          addRegionHint(metadata.originRegion)
          addRegionHint(extractAwsRegionFromUrl(metadata.url))
          addRegionHint(extractAwsRegionFromUrl(metadata.apiGatewayUrl))

          const bucketBases = buildS3BaseCandidates(bucket, Array.from(regionHints))
          if (!bucketBases.length) {
            return false
          }

          const originPath = normalizeAliasOriginPath(metadata.originPath)
          const baseCandidates = []
          const seenBases = new Set()

          const appendBaseCandidate = (base) => {
            if (!base || seenBases.has(base)) {
              return
            }
            seenBases.add(base)
            baseCandidates.push(base)
          }

          bucketBases.forEach((base) => {
            appendBaseCandidate(base)
            if (originPath && shouldAppendOriginPathToBase(base, originPath)) {
              appendBaseCandidate(joinAliasUrl(base, originPath))
            }
          })

          if (!baseCandidates.length) {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const originalSource = describeSource(element)
          const preferredAssetPath = (() => {
            const normalizedSource = stripInlineAssetAnnotations(originalSource || '')
            if (normalizedSource && HASHED_INDEX_ASSET_PATTERN.test(normalizedSource)) {
              return normalizedSource
            }
            return isScript ? aliasPaths.js : aliasPaths.css
          })()

          if (!preferredAssetPath) {
            return false
          }

          const candidateAssets = []
          if (preferredAssetPath) {
            candidateAssets.push(preferredAssetPath)
          }
          const aliasPath = isScript ? aliasPaths.js : aliasPaths.css
          if (aliasPath && aliasPath !== preferredAssetPath) {
            candidateAssets.push(aliasPath)
          }

          if (!candidateAssets.length) {
            return false
          }

          const rawAttempt = element.dataset?.resumeforgeS3Attempt || '0'
          let attemptIndex = Number.parseInt(rawAttempt, 10)
          if (!Number.isFinite(attemptIndex) || attemptIndex < 0) {
            attemptIndex = 0
          }

          const totalCombinations = candidateAssets.length * baseCandidates.length
          let nextPointer = attemptIndex
          let selectedUrl = ''
          let selectedAsset = ''
          let selectedBase = ''

          while (nextPointer < totalCombinations) {
            const assetIndex = Math.floor(nextPointer / baseCandidates.length)
            const baseIndex = nextPointer % baseCandidates.length
            const assetCandidate = candidateAssets[assetIndex]
            const baseCandidate = baseCandidates[baseIndex]
            const joined = joinAliasUrl(baseCandidate, assetCandidate)
            nextPointer += 1

            if (joined) {
              selectedUrl = joined
              selectedAsset = assetCandidate
              selectedBase = baseCandidate
              break
            }
          }

          element.dataset.resumeforgeS3Attempt = String(nextPointer)

          if (!selectedUrl) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const replacement = element.cloneNode(true)
          const cacheBustedUrl = appendCacheBustParam(selectedUrl)
          const effectiveUrl = cacheBustedUrl || selectedUrl

          if (isStylesheet) {
            replacement.href = effectiveUrl
          } else {
            replacement.src = effectiveUrl
          }

          replacement.setAttribute('data-src', effectiveUrl)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeAssetS3 = 'true'
          replacement.dataset.resumeforgeS3Attempt = String(nextPointer)
          if (selectedAsset) {
            replacement.dataset.resumeforgeS3Asset = selectedAsset
          }
          if (selectedBase) {
            replacement.dataset.resumeforgeS3Base = selectedBase
          }
          if (originalSource) {
            replacement.dataset.resumeforgeOriginalSource = originalSource
          }

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeAssetS3 = 'true'
          element.dataset.resumeforgeS3Attempt = String(nextPointer)
          if (selectedAsset && !element.dataset.resumeforgeS3Asset) {
            element.dataset.resumeforgeS3Asset = selectedAsset
          }
          if (selectedBase && !element.dataset.resumeforgeS3Base) {
            element.dataset.resumeforgeS3Base = selectedBase
          }
          if (originalSource && !element.dataset.resumeforgeOriginalSource) {
            element.dataset.resumeforgeOriginalSource = originalSource
          }

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset via S3 origin fallback.', {
              source: originalSource || '',
              target: effectiveUrl,
              base: selectedBase || '',
              asset: selectedAsset || ''
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        function attemptAliasReload(element) {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          const attemptIndex = Number.parseInt(element.dataset?.resumeforgeAliasAttempt || '0', 10)
          if (!Number.isFinite(attemptIndex) || attemptIndex < 0) {
            return false
          }

          const dataset = element?.dataset
          if (attemptIndex >= aliasBaseCandidates.length) {
            if (dataset?.resumeforgeAliasMetadataPending === 'true') {
              return true
            }

            if (
              dataset?.resumeforgeAliasMetadataAttempted === 'true' ||
              aliasMetadataLoaded
            ) {
              if (attemptStaticProxyReload(element)) {
                return true
              }
              return false
            }

            const metadataPromise = ensureAliasMetadataLoaded()
            if (metadataPromise) {
              try {
                if (dataset) {
                  dataset.resumeforgeAliasMetadataPending = 'true'
                }
              } catch (error) {
                // Ignore dataset assignment failures in constrained environments.
              }

              const handleResolution = (callback) => {
                if (!element) {
                  return
                }

                let connected = true
                if (typeof element.isConnected === 'boolean') {
                  connected = element.isConnected
                } else {
                  const root = document?.documentElement
                  connected = Boolean(root && typeof root.contains === 'function' && root.contains(element))
                }

                if (!connected) {
                  return
                }

                callback()
              }

              metadataPromise
                .then((added) => {
                  try {
                    if (dataset) {
                      delete dataset.resumeforgeAliasMetadataPending
                      if (added) {
                        delete dataset.resumeforgeAliasMetadataAttempted
                      } else {
                        dataset.resumeforgeAliasMetadataAttempted = 'true'
                      }
                    }
                  } catch (error) {
                    // Ignore dataset mutation failures when clearing metadata state.
                  }

                  if (added) {
                    handleResolution(() => {
                      attemptAliasReload(element)
                    })
                    return
                  }

                  handleResolution(() => {
                    if (!attemptProxyOrAliasReload(element)) {
                      attemptStaticProxyReload(element)
                    }
                  })
                })
                .catch(() => {
                  try {
                    if (dataset) {
                      delete dataset.resumeforgeAliasMetadataPending
                      dataset.resumeforgeAliasMetadataAttempted = 'true'
                    }
                  } catch (error) {
                    // Ignore dataset mutation failures when clearing metadata state.
                  }

                  handleResolution(() => {
                    if (!attemptProxyOrAliasReload(element)) {
                      attemptStaticProxyReload(element)
                    }
                  })
                })

              return true
            }

            try {
              if (dataset) {
                dataset.resumeforgeAliasMetadataAttempted = 'true'
              }
            } catch (error) {
              // Ignore dataset mutation failures when recording metadata exhaustion.
            }

            if (attemptStaticProxyReload(element)) {
              return true
            }
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const aliasPath = isScript ? aliasPaths.js : aliasPaths.css
          if (!aliasPath) {
            return false
          }

          const { url: aliasUrl, base: aliasBase } = buildAliasUrlForAttempt(aliasPath, attemptIndex)
          if (!aliasUrl) {
            return false
          }

          const parent = element.parentNode
          if (!parent || typeof parent.replaceChild !== 'function') {
            return false
          }

          const originalSource = describeSource(element)
          const replacement = element.cloneNode(true)

          const cacheBustedAliasUrl = appendCacheBustParam(aliasUrl)
          const effectiveAliasUrl = cacheBustedAliasUrl || aliasUrl

          if (isStylesheet) {
            replacement.href = effectiveAliasUrl
          } else {
            replacement.src = effectiveAliasUrl
          }

          replacement.setAttribute('data-src', effectiveAliasUrl)
          replacement.dataset.resumeforgeAssetRetry = 'true'
          replacement.dataset.resumeforgeAssetAlias = 'true'
          replacement.dataset.resumeforgeAliasAttempt = String(attemptIndex + 1)
          if (aliasBase) {
            replacement.dataset.resumeforgeAliasBase = aliasBase
          }
          if (originalSource) {
            replacement.dataset.resumeforgeOriginalSource = originalSource
          }

          element.dataset.resumeforgeAssetRetry = 'true'
          element.dataset.resumeforgeAssetAlias = 'true'
          element.dataset.resumeforgeAliasAttempt = String(attemptIndex + 1)
          if (aliasBase) {
            element.dataset.resumeforgeAliasBase = aliasBase
          }
          if (originalSource && !element.dataset.resumeforgeOriginalSource) {
            element.dataset.resumeforgeOriginalSource = originalSource
          }

          try {
            parent.replaceChild(replacement, element)
          } catch (error) {
            try {
              parent.removeChild(element)
              parent.appendChild(replacement)
            } catch (innerError) {
              return false
            }
          }

          try {
            console.warn('Retrying ResumeForge static asset via alias fallback.', {
              source: originalSource || '',
              alias: aliasUrl,
              resolved: effectiveAliasUrl,
              base: aliasBase
            })
          } catch (error) {
            // Ignore logging errors in constrained environments.
          }

          return true
        }

        const attemptManifestReload = (element) => {
          if (!element || typeof element.tagName !== 'string') {
            return false
          }

          const tagName = element.tagName.toLowerCase()
          const isStylesheet =
            tagName === 'link' && typeof element.rel === 'string' && element.rel.toLowerCase() === 'stylesheet'
          const isScript = tagName === 'script'

          if (!isScript && !isStylesheet) {
            return false
          }

          const extension = isStylesheet ? 'css' : 'js'
          const originalSource = describeSource(element)

          const applyCandidates = (candidates) => {
            const list = Array.isArray(candidates?.[extension]) ? candidates[extension] : []
            if (!list.length) {
              return false
            }

            const rawAttempt = element.dataset?.resumeforgeManifestAttempt || '0'
            const parsedAttempt = Number.parseInt(rawAttempt, 10)
            const startIndex = Number.isFinite(parsedAttempt) && parsedAttempt >= 0 ? parsedAttempt : 0

            for (let index = startIndex; index < list.length; index += 1) {
              const candidate = list[index]
              if (!candidate) {
                continue
              }

              let normalizedCandidate = candidate
              try {
                const resolved = new URL(candidate, window.location.href)
                normalizedCandidate =
                  resolved.origin === window.location.origin
                    ? `${resolved.pathname}${resolved.search}`
                    : resolved.href
              } catch (error) {
                normalizedCandidate = candidate
              }

              if (normalizedCandidate && originalSource && normalizedCandidate === originalSource) {
                element.dataset.resumeforgeManifestAttempt = String(index + 1)
                continue
              }

              const parent = element.parentNode
              if (!parent || typeof parent.replaceChild !== 'function') {
                return false
              }

              const replacement = element.cloneNode(true)

              if (isStylesheet) {
                replacement.href = candidate
              } else {
                replacement.src = candidate
              }

              replacement.setAttribute('data-src', candidate)
              replacement.dataset.resumeforgeAssetRetry = 'true'
              replacement.dataset.resumeforgeAssetManifest = 'true'
              replacement.dataset.resumeforgeManifestAttempt = String(index + 1)
              if (originalSource) {
                replacement.dataset.resumeforgeOriginalSource = originalSource
              }

              element.dataset.resumeforgeAssetRetry = 'true'
              element.dataset.resumeforgeAssetManifest = 'true'
              element.dataset.resumeforgeManifestAttempt = String(index + 1)
              if (originalSource && !element.dataset.resumeforgeOriginalSource) {
                element.dataset.resumeforgeOriginalSource = originalSource
              }

              try {
                parent.replaceChild(replacement, element)
              } catch (error) {
                try {
                  parent.removeChild(element)
                  parent.appendChild(replacement)
                } catch (innerError) {
                  return false
                }
              }

              try {
                console.warn('Retrying ResumeForge static asset via manifest fallback.', {
                  source: originalSource || '',
                  manifest: candidate
                })
              } catch (error) {
                // Ignore logging errors in constrained environments.
              }

              return true
            }

            return false
          }

          if (applyCandidates(manifestState.candidatesByExtension)) {
            return true
          }

          const promise = ensureManifestCandidatesLoaded()
          if (!promise) {
            return false
          }

          promise
            .then((candidates) => {
              if (!candidates) {
                attemptProxyOrAliasReload(element)
                return
              }

              const connected = (() => {
                if (!element) {
                  return false
                }
                if (typeof element.isConnected === 'boolean') {
                  return element.isConnected
                }
                const root = document?.documentElement
                if (!root || typeof root.contains !== 'function') {
                  return true
                }
                return root.contains(element)
              })()

              if (!connected) {
                return
              }

              if (!applyCandidates(candidates)) {
                attemptProxyOrAliasReload(element)
              }
            })
            .catch(() => {
              attemptProxyOrAliasReload(element)
            })

          return true
        }

        window.addEventListener(
          'error',
          (event) => {
            if (!event || !event.target) {
              return
            }

            const target = event.target
            const tagName = typeof target.tagName === 'string' ? target.tagName.toLowerCase() : ''
            const isStylesheet = tagName === 'link' && typeof target.rel === 'string' && target.rel.toLowerCase() === 'stylesheet'
            const isScript = tagName === 'script'

            if (!isScript && !isStylesheet) {
              return
            }

            if (attemptManifestReload(target)) {
              return
            }

            if (attemptProxyOrAliasReload(target)) {
              return
            }

            if (attemptCacheBustingReload(target)) {
              return
            }

            const sourceText = describeSource(target)

            if (attemptHardRefresh()) {
              return
            }

            revealWarning(sourceText)
            logFailure(sourceText)
          },
          true
        )

        window.addEventListener('unhandledrejection', (event) => {
          if (!event || !event.reason) {
            return
          }

          const reason = event.reason
          const message =
            typeof reason === 'string'
              ? reason
              : typeof reason.message === 'string'
                ? reason.message
                : typeof reason.error === 'string'
                  ? reason.error
                  : ''

          if (!message) {
            return
          }

          if (/loading chunk|importing module|Failed to fetch dynamically imported module|module script/i.test(message)) {
            revealWarning('')
            logFailure('')
          }
        })
      })()
    </script>
    <script type="module">
      const DEV_ENTRY_SOURCE = '/src/main.jsx'
      const PROD_ENTRY_SOURCE = '/assets/index-latest.js'
      const PROD_STYLESHEET_HREF =
        typeof window !== 'undefined' && window.__RESUMEFORGE_HAS_INDEX_CSS__
          ? '/assets/index-latest.css'
          : ''

      const detectDevEnvironment = () => {
        try {
          return Boolean(import.meta?.env?.DEV)
        } catch (error) {
          if (typeof window !== 'undefined' && window.location) {
            const host = window.location.hostname || ''
            return host === 'localhost' || host === '127.0.0.1'
          }
          return false
        }
      }

      const appendStylesheet = (href) => {
        if (typeof href !== 'string' || !href.trim()) {
          return Promise.resolve()
        }

        return new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = href
          link.setAttribute('data-src', href)
          link.dataset.resumeforgeEntry = 'true'

          link.addEventListener('load', () => resolve(), { once: true })
          link.addEventListener(
            'error',
            (event) => {
              reject(event?.error || new Error(`Failed to load stylesheet: ${href}`))
            },
            { once: true }
          )

          document.head.appendChild(link)
        })
      }

      const appendModuleScript = (src) => {
        if (typeof src !== 'string' || !src.trim()) {
          return Promise.reject(new Error('Missing module source.'))
        }

        return new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.type = 'module'
          script.async = false
          script.src = src
          script.setAttribute('data-src', src)
          script.dataset.resumeforgeEntry = 'true'

          script.addEventListener('load', () => resolve(), { once: true })
          script.addEventListener(
            'error',
            (event) => {
              reject(event?.error || new Error(`Failed to load module script: ${src}`))
            },
            { once: true }
          )

          document.body.appendChild(script)
        })
      }

      const bootstrap = async () => {
        const devEnvironment = detectDevEnvironment()

        if (devEnvironment) {
          await appendModuleScript(DEV_ENTRY_SOURCE)
          return
        }

        try {
          await appendStylesheet(PROD_STYLESHEET_HREF)
        } catch (error) {
          console.warn('ResumeForge entry stylesheet failed to load.', {
            source: PROD_STYLESHEET_HREF,
            error,
          })
        }

        await appendModuleScript(PROD_ENTRY_SOURCE)
      }

      bootstrap().catch((error) => {
        console.error('ResumeForge client bootstrap failed.', error)
      })
    </script>
  </body>
</html>
